/* automatically generated by rust-bindgen 0.64.0 */

#[doc = " hb_bool_t:\n\n Data type for booleans.\n"]
pub type hb_bool_t = ::std::os::raw::c_int;
#[doc = " hb_codepoint_t:\n\n Data type for holding Unicode codepoints. Also\n used to hold glyph IDs.\n"]
pub type hb_codepoint_t = u32;
#[doc = " hb_position_t:\n\n Data type for holding a single coordinate value.\n Contour points and other multi-dimensional data are\n stored as tuples of #hb_position_t's.\n"]
pub type hb_position_t = i32;
#[doc = " hb_mask_t:\n\n Data type for bitmasks.\n"]
pub type hb_mask_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_int_t {
    pub u32: u32,
    pub i32: i32,
    pub u16: [u16; 2usize],
    pub i16: [i16; 2usize],
    pub u8: [u8; 4usize],
    pub i8: [i8; 4usize],
}
#[test]
fn bindgen_test_layout__hb_var_int_t() {
    const UNINIT: ::std::mem::MaybeUninit<_hb_var_int_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hb_var_int_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i8)
        )
    );
}
pub type hb_var_int_t = _hb_var_int_t;
#[doc = " hb_tag_t:\n\n Data type for tag identifiers. Tags are four\n byte integers, each byte representing a character.\n\n Tags are used to identify tables, design-variation axes,\n scripts, languages, font features, and baselines with\n human-readable names.\n"]
pub type hb_tag_t = u32;
extern "C" {
    pub fn hb_tag_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_tag_t;
}
extern "C" {
    pub fn hb_tag_to_string(tag: hb_tag_t, buf: *mut ::std::os::raw::c_char);
}
pub const HB_DIRECTION_INVALID: hb_direction_t = 0;
pub const HB_DIRECTION_LTR: hb_direction_t = 4;
pub const HB_DIRECTION_RTL: hb_direction_t = 5;
pub const HB_DIRECTION_TTB: hb_direction_t = 6;
pub const HB_DIRECTION_BTT: hb_direction_t = 7;
#[doc = " hb_direction_t:\n @HB_DIRECTION_INVALID: Initial, unset direction.\n @HB_DIRECTION_LTR: Text is set horizontally from left to right.\n @HB_DIRECTION_RTL: Text is set horizontally from right to left.\n @HB_DIRECTION_TTB: Text is set vertically from top to bottom.\n @HB_DIRECTION_BTT: Text is set vertically from bottom to top.\n\n The direction of a text segment or buffer.\n\n A segment can also be tested for horizontal or vertical\n orientation (irrespective of specific direction) with\n HB_DIRECTION_IS_HORIZONTAL() or HB_DIRECTION_IS_VERTICAL().\n"]
pub type hb_direction_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_direction_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_direction_t;
}
extern "C" {
    pub fn hb_direction_to_string(direction: hb_direction_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_language_impl_t {
    _unused: [u8; 0],
}
pub type hb_language_t = *const hb_language_impl_t;
extern "C" {
    pub fn hb_language_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_language_t;
}
extern "C" {
    pub fn hb_language_to_string(language: hb_language_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_language_get_default() -> hb_language_t;
}
pub const HB_SCRIPT_COMMON: hb_script_t = 1517910393;
pub const HB_SCRIPT_INHERITED: hb_script_t = 1516858984;
pub const HB_SCRIPT_UNKNOWN: hb_script_t = 1517976186;
pub const HB_SCRIPT_ARABIC: hb_script_t = 1098015074;
pub const HB_SCRIPT_ARMENIAN: hb_script_t = 1098018158;
pub const HB_SCRIPT_BENGALI: hb_script_t = 1113943655;
pub const HB_SCRIPT_CYRILLIC: hb_script_t = 1132032620;
pub const HB_SCRIPT_DEVANAGARI: hb_script_t = 1147500129;
pub const HB_SCRIPT_GEORGIAN: hb_script_t = 1197830002;
pub const HB_SCRIPT_GREEK: hb_script_t = 1198679403;
pub const HB_SCRIPT_GUJARATI: hb_script_t = 1198877298;
pub const HB_SCRIPT_GURMUKHI: hb_script_t = 1198879349;
pub const HB_SCRIPT_HANGUL: hb_script_t = 1214344807;
pub const HB_SCRIPT_HAN: hb_script_t = 1214344809;
pub const HB_SCRIPT_HEBREW: hb_script_t = 1214603890;
pub const HB_SCRIPT_HIRAGANA: hb_script_t = 1214870113;
pub const HB_SCRIPT_KANNADA: hb_script_t = 1265525857;
pub const HB_SCRIPT_KATAKANA: hb_script_t = 1264676449;
pub const HB_SCRIPT_LAO: hb_script_t = 1281453935;
pub const HB_SCRIPT_LATIN: hb_script_t = 1281455214;
pub const HB_SCRIPT_MALAYALAM: hb_script_t = 1298954605;
pub const HB_SCRIPT_ORIYA: hb_script_t = 1332902241;
pub const HB_SCRIPT_TAMIL: hb_script_t = 1415671148;
pub const HB_SCRIPT_TELUGU: hb_script_t = 1415933045;
pub const HB_SCRIPT_THAI: hb_script_t = 1416126825;
pub const HB_SCRIPT_TIBETAN: hb_script_t = 1416192628;
pub const HB_SCRIPT_BOPOMOFO: hb_script_t = 1114599535;
pub const HB_SCRIPT_BRAILLE: hb_script_t = 1114792297;
pub const HB_SCRIPT_CANADIAN_SYLLABICS: hb_script_t = 1130458739;
pub const HB_SCRIPT_CHEROKEE: hb_script_t = 1130915186;
pub const HB_SCRIPT_ETHIOPIC: hb_script_t = 1165256809;
pub const HB_SCRIPT_KHMER: hb_script_t = 1265134962;
pub const HB_SCRIPT_MONGOLIAN: hb_script_t = 1299148391;
pub const HB_SCRIPT_MYANMAR: hb_script_t = 1299803506;
pub const HB_SCRIPT_OGHAM: hb_script_t = 1332175213;
pub const HB_SCRIPT_RUNIC: hb_script_t = 1383427698;
pub const HB_SCRIPT_SINHALA: hb_script_t = 1399418472;
pub const HB_SCRIPT_SYRIAC: hb_script_t = 1400468067;
pub const HB_SCRIPT_THAANA: hb_script_t = 1416126817;
pub const HB_SCRIPT_YI: hb_script_t = 1500080489;
pub const HB_SCRIPT_DESERET: hb_script_t = 1148416628;
pub const HB_SCRIPT_GOTHIC: hb_script_t = 1198486632;
pub const HB_SCRIPT_OLD_ITALIC: hb_script_t = 1232363884;
pub const HB_SCRIPT_BUHID: hb_script_t = 1114990692;
pub const HB_SCRIPT_HANUNOO: hb_script_t = 1214344815;
pub const HB_SCRIPT_TAGALOG: hb_script_t = 1416064103;
pub const HB_SCRIPT_TAGBANWA: hb_script_t = 1415669602;
pub const HB_SCRIPT_CYPRIOT: hb_script_t = 1131442804;
pub const HB_SCRIPT_LIMBU: hb_script_t = 1281977698;
pub const HB_SCRIPT_LINEAR_B: hb_script_t = 1281977954;
pub const HB_SCRIPT_OSMANYA: hb_script_t = 1332964705;
pub const HB_SCRIPT_SHAVIAN: hb_script_t = 1399349623;
pub const HB_SCRIPT_TAI_LE: hb_script_t = 1415670885;
pub const HB_SCRIPT_UGARITIC: hb_script_t = 1432838514;
pub const HB_SCRIPT_BUGINESE: hb_script_t = 1114990441;
pub const HB_SCRIPT_COPTIC: hb_script_t = 1131376756;
pub const HB_SCRIPT_GLAGOLITIC: hb_script_t = 1198285159;
pub const HB_SCRIPT_KHAROSHTHI: hb_script_t = 1265131890;
pub const HB_SCRIPT_NEW_TAI_LUE: hb_script_t = 1415670901;
pub const HB_SCRIPT_OLD_PERSIAN: hb_script_t = 1483761007;
pub const HB_SCRIPT_SYLOTI_NAGRI: hb_script_t = 1400466543;
pub const HB_SCRIPT_TIFINAGH: hb_script_t = 1415999079;
pub const HB_SCRIPT_BALINESE: hb_script_t = 1113681001;
pub const HB_SCRIPT_CUNEIFORM: hb_script_t = 1483961720;
pub const HB_SCRIPT_NKO: hb_script_t = 1315663727;
pub const HB_SCRIPT_PHAGS_PA: hb_script_t = 1349017959;
pub const HB_SCRIPT_PHOENICIAN: hb_script_t = 1349021304;
pub const HB_SCRIPT_CARIAN: hb_script_t = 1130459753;
pub const HB_SCRIPT_CHAM: hb_script_t = 1130914157;
pub const HB_SCRIPT_KAYAH_LI: hb_script_t = 1264675945;
pub const HB_SCRIPT_LEPCHA: hb_script_t = 1281716323;
pub const HB_SCRIPT_LYCIAN: hb_script_t = 1283023721;
pub const HB_SCRIPT_LYDIAN: hb_script_t = 1283023977;
pub const HB_SCRIPT_OL_CHIKI: hb_script_t = 1332503403;
pub const HB_SCRIPT_REJANG: hb_script_t = 1382706791;
pub const HB_SCRIPT_SAURASHTRA: hb_script_t = 1398895986;
pub const HB_SCRIPT_SUNDANESE: hb_script_t = 1400204900;
pub const HB_SCRIPT_VAI: hb_script_t = 1449224553;
pub const HB_SCRIPT_AVESTAN: hb_script_t = 1098281844;
pub const HB_SCRIPT_BAMUM: hb_script_t = 1113681269;
pub const HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: hb_script_t = 1164409200;
pub const HB_SCRIPT_IMPERIAL_ARAMAIC: hb_script_t = 1098018153;
pub const HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: hb_script_t = 1349020777;
pub const HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: hb_script_t = 1349678185;
pub const HB_SCRIPT_JAVANESE: hb_script_t = 1247901281;
pub const HB_SCRIPT_KAITHI: hb_script_t = 1265920105;
pub const HB_SCRIPT_LISU: hb_script_t = 1281979253;
pub const HB_SCRIPT_MEETEI_MAYEK: hb_script_t = 1299473769;
pub const HB_SCRIPT_OLD_SOUTH_ARABIAN: hb_script_t = 1398895202;
pub const HB_SCRIPT_OLD_TURKIC: hb_script_t = 1332898664;
pub const HB_SCRIPT_SAMARITAN: hb_script_t = 1398893938;
pub const HB_SCRIPT_TAI_THAM: hb_script_t = 1281453665;
pub const HB_SCRIPT_TAI_VIET: hb_script_t = 1415673460;
pub const HB_SCRIPT_BATAK: hb_script_t = 1113683051;
pub const HB_SCRIPT_BRAHMI: hb_script_t = 1114792296;
pub const HB_SCRIPT_MANDAIC: hb_script_t = 1298230884;
pub const HB_SCRIPT_CHAKMA: hb_script_t = 1130457965;
pub const HB_SCRIPT_MEROITIC_CURSIVE: hb_script_t = 1298494051;
pub const HB_SCRIPT_MEROITIC_HIEROGLYPHS: hb_script_t = 1298494063;
pub const HB_SCRIPT_MIAO: hb_script_t = 1349284452;
pub const HB_SCRIPT_SHARADA: hb_script_t = 1399353956;
pub const HB_SCRIPT_SORA_SOMPENG: hb_script_t = 1399812705;
pub const HB_SCRIPT_TAKRI: hb_script_t = 1415670642;
pub const HB_SCRIPT_BASSA_VAH: hb_script_t = 1113682803;
pub const HB_SCRIPT_CAUCASIAN_ALBANIAN: hb_script_t = 1097295970;
pub const HB_SCRIPT_DUPLOYAN: hb_script_t = 1148547180;
pub const HB_SCRIPT_ELBASAN: hb_script_t = 1164730977;
pub const HB_SCRIPT_GRANTHA: hb_script_t = 1198678382;
pub const HB_SCRIPT_KHOJKI: hb_script_t = 1265135466;
pub const HB_SCRIPT_KHUDAWADI: hb_script_t = 1399418468;
pub const HB_SCRIPT_LINEAR_A: hb_script_t = 1281977953;
pub const HB_SCRIPT_MAHAJANI: hb_script_t = 1298229354;
pub const HB_SCRIPT_MANICHAEAN: hb_script_t = 1298230889;
pub const HB_SCRIPT_MENDE_KIKAKUI: hb_script_t = 1298493028;
pub const HB_SCRIPT_MODI: hb_script_t = 1299145833;
pub const HB_SCRIPT_MRO: hb_script_t = 1299345263;
pub const HB_SCRIPT_NABATAEAN: hb_script_t = 1315070324;
pub const HB_SCRIPT_OLD_NORTH_ARABIAN: hb_script_t = 1315009122;
pub const HB_SCRIPT_OLD_PERMIC: hb_script_t = 1348825709;
pub const HB_SCRIPT_PAHAWH_HMONG: hb_script_t = 1215131239;
pub const HB_SCRIPT_PALMYRENE: hb_script_t = 1348562029;
pub const HB_SCRIPT_PAU_CIN_HAU: hb_script_t = 1348564323;
pub const HB_SCRIPT_PSALTER_PAHLAVI: hb_script_t = 1349020784;
pub const HB_SCRIPT_SIDDHAM: hb_script_t = 1399415908;
pub const HB_SCRIPT_TIRHUTA: hb_script_t = 1416196712;
pub const HB_SCRIPT_WARANG_CITI: hb_script_t = 1466004065;
pub const HB_SCRIPT_AHOM: hb_script_t = 1097363309;
pub const HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: hb_script_t = 1215067511;
pub const HB_SCRIPT_HATRAN: hb_script_t = 1214346354;
pub const HB_SCRIPT_MULTANI: hb_script_t = 1299541108;
pub const HB_SCRIPT_OLD_HUNGARIAN: hb_script_t = 1215655527;
pub const HB_SCRIPT_SIGNWRITING: hb_script_t = 1399287415;
pub const HB_SCRIPT_ADLAM: hb_script_t = 1097100397;
pub const HB_SCRIPT_BHAIKSUKI: hb_script_t = 1114139507;
pub const HB_SCRIPT_MARCHEN: hb_script_t = 1298231907;
pub const HB_SCRIPT_OSAGE: hb_script_t = 1332963173;
pub const HB_SCRIPT_TANGUT: hb_script_t = 1415671399;
pub const HB_SCRIPT_NEWA: hb_script_t = 1315272545;
pub const HB_SCRIPT_MASARAM_GONDI: hb_script_t = 1198485101;
pub const HB_SCRIPT_NUSHU: hb_script_t = 1316186229;
pub const HB_SCRIPT_SOYOMBO: hb_script_t = 1399814511;
pub const HB_SCRIPT_ZANABAZAR_SQUARE: hb_script_t = 1516334690;
pub const HB_SCRIPT_DOGRA: hb_script_t = 1148151666;
pub const HB_SCRIPT_GUNJALA_GONDI: hb_script_t = 1198485095;
pub const HB_SCRIPT_HANIFI_ROHINGYA: hb_script_t = 1383032935;
pub const HB_SCRIPT_MAKASAR: hb_script_t = 1298230113;
pub const HB_SCRIPT_MEDEFAIDRIN: hb_script_t = 1298490470;
pub const HB_SCRIPT_OLD_SOGDIAN: hb_script_t = 1399809903;
pub const HB_SCRIPT_SOGDIAN: hb_script_t = 1399809892;
pub const HB_SCRIPT_ELYMAIC: hb_script_t = 1164736877;
pub const HB_SCRIPT_NANDINAGARI: hb_script_t = 1315008100;
pub const HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: hb_script_t = 1215131248;
pub const HB_SCRIPT_WANCHO: hb_script_t = 1466132591;
pub const HB_SCRIPT_CHORASMIAN: hb_script_t = 1130918515;
pub const HB_SCRIPT_DIVES_AKURU: hb_script_t = 1147756907;
pub const HB_SCRIPT_KHITAN_SMALL_SCRIPT: hb_script_t = 1265202291;
pub const HB_SCRIPT_YEZIDI: hb_script_t = 1499822697;
pub const HB_SCRIPT_INVALID: hb_script_t = 0;
pub const _HB_SCRIPT_MAX_VALUE: hb_script_t = 2147483647;
pub const _HB_SCRIPT_MAX_VALUE_SIGNED: hb_script_t = 2147483647;
#[doc = " hb_script_t:\n @HB_SCRIPT_COMMON: HB_TAG ('Z','y','y','y')\n @HB_SCRIPT_INHERITED: HB_TAG ('Z','i','n','h')\n @HB_SCRIPT_UNKNOWN: HB_TAG ('Z','z','z','z')\n @HB_SCRIPT_ARABIC\n @HB_SCRIPT_ARMENIAN\n @HB_SCRIPT_BENGALI\n @HB_SCRIPT_CYRILLIC\n @HB_SCRIPT_DEVANAGARI\n @HB_SCRIPT_GEORGIAN\n @HB_SCRIPT_GREEK\n @HB_SCRIPT_GUJARATI\n @HB_SCRIPT_GURMUKHI\n @HB_SCRIPT_HANGUL\n @HB_SCRIPT_HAN\n @HB_SCRIPT_HEBREW\n @HB_SCRIPT_HIRAGANA\n @HB_SCRIPT_KANNADA\n @HB_SCRIPT_KATAKANA\n @HB_SCRIPT_LAO\n @HB_SCRIPT_LATIN\n @HB_SCRIPT_MALAYALAM\n @HB_SCRIPT_ORIYA\n @HB_SCRIPT_TAMIL\n @HB_SCRIPT_TELUGU\n @HB_SCRIPT_THAI\n @HB_SCRIPT_TIBETAN\n @HB_SCRIPT_BOPOMOFO\n @HB_SCRIPT_BRAILLE\n @HB_SCRIPT_CANADIAN_SYLLABICS\n @HB_SCRIPT_CHEROKEE\n @HB_SCRIPT_ETHIOPIC\n @HB_SCRIPT_KHMER\n @HB_SCRIPT_MONGOLIAN\n @HB_SCRIPT_MYANMAR\n @HB_SCRIPT_OGHAM\n @HB_SCRIPT_RUNIC\n @HB_SCRIPT_SINHALA\n @HB_SCRIPT_SYRIAC\n @HB_SCRIPT_THAANA\n @HB_SCRIPT_YI\n @HB_SCRIPT_DESERET\n @HB_SCRIPT_GOTHIC\n @HB_SCRIPT_OLD_ITALIC\n @HB_SCRIPT_BUHID\n @HB_SCRIPT_HANUNOO\n @HB_SCRIPT_TAGALOG\n @HB_SCRIPT_TAGBANWA\n @HB_SCRIPT_CYPRIOT\n @HB_SCRIPT_LIMBU\n @HB_SCRIPT_LINEAR_B\n @HB_SCRIPT_OSMANYA\n @HB_SCRIPT_SHAVIAN\n @HB_SCRIPT_TAI_LE\n @HB_SCRIPT_UGARITIC\n @HB_SCRIPT_BUGINESE\n @HB_SCRIPT_COPTIC\n @HB_SCRIPT_GLAGOLITIC\n @HB_SCRIPT_KHAROSHTHI\n @HB_SCRIPT_NEW_TAI_LUE\n @HB_SCRIPT_OLD_PERSIAN\n @HB_SCRIPT_SYLOTI_NAGRI\n @HB_SCRIPT_TIFINAGH\n @HB_SCRIPT_BALINESE\n @HB_SCRIPT_CUNEIFORM\n @HB_SCRIPT_NKO\n @HB_SCRIPT_PHAGS_PA\n @HB_SCRIPT_PHOENICIAN\n @HB_SCRIPT_CARIAN\n @HB_SCRIPT_CHAM\n @HB_SCRIPT_KAYAH_LI\n @HB_SCRIPT_LEPCHA\n @HB_SCRIPT_LYCIAN\n @HB_SCRIPT_LYDIAN\n @HB_SCRIPT_OL_CHIKI\n @HB_SCRIPT_REJANG\n @HB_SCRIPT_SAURASHTRA\n @HB_SCRIPT_SUNDANESE\n @HB_SCRIPT_VAI\n @HB_SCRIPT_AVESTAN\n @HB_SCRIPT_BAMUM\n @HB_SCRIPT_EGYPTIAN_HIEROGLYPHS\n @HB_SCRIPT_IMPERIAL_ARAMAIC\n @HB_SCRIPT_INSCRIPTIONAL_PAHLAVI\n @HB_SCRIPT_INSCRIPTIONAL_PARTHIAN\n @HB_SCRIPT_JAVANESE\n @HB_SCRIPT_KAITHI\n @HB_SCRIPT_LISU\n @HB_SCRIPT_MEETEI_MAYEK\n @HB_SCRIPT_OLD_SOUTH_ARABIAN\n @HB_SCRIPT_OLD_TURKIC\n @HB_SCRIPT_SAMARITAN\n @HB_SCRIPT_TAI_THAM\n @HB_SCRIPT_TAI_VIET\n @HB_SCRIPT_BATAK\n @HB_SCRIPT_BRAHMI\n @HB_SCRIPT_MANDAIC\n @HB_SCRIPT_CHAKMA\n @HB_SCRIPT_MEROITIC_CURSIVE\n @HB_SCRIPT_MEROITIC_HIEROGLYPHS\n @HB_SCRIPT_MIAO\n @HB_SCRIPT_SHARADA\n @HB_SCRIPT_SORA_SOMPENG\n @HB_SCRIPT_TAKRI\n @HB_SCRIPT_BASSA_VAH\n @HB_SCRIPT_CAUCASIAN_ALBANIAN\n @HB_SCRIPT_DUPLOYAN\n @HB_SCRIPT_ELBASAN\n @HB_SCRIPT_GRANTHA\n @HB_SCRIPT_KHOJKI\n @HB_SCRIPT_KHUDAWADI\n @HB_SCRIPT_LINEAR_A\n @HB_SCRIPT_MAHAJANI\n @HB_SCRIPT_MANICHAEAN\n @HB_SCRIPT_MENDE_KIKAKUI\n @HB_SCRIPT_MODI\n @HB_SCRIPT_MRO\n @HB_SCRIPT_NABATAEAN\n @HB_SCRIPT_OLD_NORTH_ARABIAN\n @HB_SCRIPT_OLD_PERMIC\n @HB_SCRIPT_PAHAWH_HMONG\n @HB_SCRIPT_PALMYRENE\n @HB_SCRIPT_PAU_CIN_HAU\n @HB_SCRIPT_PSALTER_PAHLAVI\n @HB_SCRIPT_SIDDHAM\n @HB_SCRIPT_TIRHUTA\n @HB_SCRIPT_WARANG_CITI\n @HB_SCRIPT_AHOM\n @HB_SCRIPT_ANATOLIAN_HIEROGLYPHS\n @HB_SCRIPT_HATRAN\n @HB_SCRIPT_MULTANI\n @HB_SCRIPT_OLD_HUNGARIAN\n @HB_SCRIPT_SIGNWRITING\n @HB_SCRIPT_ADLAM\n @HB_SCRIPT_BHAIKSUKI\n @HB_SCRIPT_MARCHEN\n @HB_SCRIPT_OSAGE\n @HB_SCRIPT_TANGUT\n @HB_SCRIPT_NEWA\n @HB_SCRIPT_MASARAM_GONDI\n @HB_SCRIPT_NUSHU\n @HB_SCRIPT_SOYOMBO\n @HB_SCRIPT_ZANABAZAR_SQUARE\n @HB_SCRIPT_DOGRA\n @HB_SCRIPT_GUNJALA_GONDI\n @HB_SCRIPT_HANIFI_ROHINGYA\n @HB_SCRIPT_MAKASAR\n @HB_SCRIPT_MEDEFAIDRIN\n @HB_SCRIPT_OLD_SOGDIAN\n @HB_SCRIPT_SOGDIAN\n @HB_SCRIPT_ELYMAIC\n @HB_SCRIPT_NANDINAGARI\n @HB_SCRIPT_NYIAKENG_PUACHUE_HMONG\n @HB_SCRIPT_WANCHO\n @HB_SCRIPT_INVALID: #HB_TAG_NONE\n\n Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding\n to the four-letter values defined by [ISO 15924](https://unicode.org/iso15924/).\n\n See also the Script (sc) property of the Unicode Character Database.\n"]
pub type hb_script_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_script_from_iso15924_tag(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_to_iso15924_tag(script: hb_script_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_script_get_horizontal_direction(script: hb_script_t) -> hb_direction_t;
}
#[doc = " hb_user_data_key_t:\n\n Data structure for holding user-data keys.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_user_data_key_t {
    pub unused: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hb_user_data_key_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_user_data_key_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Size of: ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Alignment of ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_user_data_key_t),
            "::",
            stringify!(unused)
        )
    );
}
pub type hb_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = " hb_feature_t:\n @tag: The #hb_tag_t tag of the feature\n @value: The value of the feature. 0 disables the feature, non-zero (usually\n 1) enables the feature.  For features implemented as lookup type 3 (like\n 'salt') the @value is a one based index into the alternates.\n @start: the cluster to start applying this feature setting (inclusive).\n @end: the cluster to end applying this feature setting (exclusive).\n\n The #hb_feature_t is the structure that holds information about requested\n feature application. The feature will be applied with the given value to all\n glyphs which are in clusters between @start (inclusive) and @end (exclusive).\n Setting start to @HB_FEATURE_GLOBAL_START and end to @HB_FEATURE_GLOBAL_END\n specifies that the feature always applies to the entire buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_feature_t {
    pub tag: hb_tag_t,
    pub value: u32,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_feature_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_feature_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_feature_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_feature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_feature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_feature_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn hb_feature_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        feature: *mut hb_feature_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_feature_to_string(
        feature: *mut hb_feature_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_variation_t:\n @tag: The #hb_tag_t tag of the variation-axis name\n @value: The value of the variation axis\n\n Data type for holding variation data. Registered OpenType\n variation-axis tags are listed at\n https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg\n\n Since: 1.4.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_variation_t {
    pub tag: hb_tag_t,
    pub value: ::std::os::raw::c_float,
}
#[test]
fn bindgen_test_layout_hb_variation_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_variation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_variation_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_variation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_variation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_variation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn hb_variation_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        variation: *mut hb_variation_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_variation_to_string(
        variation: *mut hb_variation_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_color_t:\n\n Data type for holding color values. Colors are eight bits per\n channel RGB plus alpha transparency.\n\n Since: 2.1.0"]
pub type hb_color_t = u32;
extern "C" {
    pub fn hb_color_get_alpha(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_red(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_green(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_blue(color: hb_color_t) -> u8;
}
pub const HB_MEMORY_MODE_DUPLICATE: hb_memory_mode_t = 0;
pub const HB_MEMORY_MODE_READONLY: hb_memory_mode_t = 1;
pub const HB_MEMORY_MODE_WRITABLE: hb_memory_mode_t = 2;
pub const HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: hb_memory_mode_t = 3;
#[doc = " hb_memory_mode_t:\n @HB_MEMORY_MODE_DUPLICATE\n @HB_MEMORY_MODE_READONLY\n @HB_MEMORY_MODE_WRITABLE\n @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE\n\n Data type holding the memory modes available to\n client programs.\n\n Regarding these various memory-modes:\n\n - In no case shall the HarfBuzz client modify memory\n   that is passed to HarfBuzz in a blob.  If there is\n   any such possibility, @HB_MEMORY_MODE_DUPLICATE should be used\n   such that HarfBuzz makes a copy immediately,\n\n - Use @HB_MEMORY_MODE_READONLY otherwise, unless you really really\n   really know what you are doing,\n\n - @HB_MEMORY_MODE_WRITABLE is appropriate if you really made a\n   copy of data solely for the purpose of passing to\n   HarfBuzz and doing that just once (no reuse!),\n\n - If the font is mmap()ed, it's okay to use\n   @HB_MEMORY_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n   correctly is very tricky.  Use @HB_MEMORY_MODE_READONLY instead."]
pub type hb_memory_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_blob_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_blob_create(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_from_file(file_name: *const ::std::os::raw::c_char) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_sub_blob(
        parent: *mut hb_blob_t,
        offset: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_copy_writable_or_fail(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_get_empty() -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_reference(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_destroy(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_set_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_blob_make_immutable(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_is_immutable(blob: *mut hb_blob_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_length(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_blob_get_data(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_blob_get_data_writable(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
pub const HB_UNICODE_GENERAL_CATEGORY_CONTROL: hb_unicode_general_category_t = 0;
pub const HB_UNICODE_GENERAL_CATEGORY_FORMAT: hb_unicode_general_category_t = 1;
pub const HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED: hb_unicode_general_category_t = 2;
pub const HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE: hb_unicode_general_category_t = 3;
pub const HB_UNICODE_GENERAL_CATEGORY_SURROGATE: hb_unicode_general_category_t = 4;
pub const HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER: hb_unicode_general_category_t = 5;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER: hb_unicode_general_category_t = 6;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER: hb_unicode_general_category_t = 7;
pub const HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER: hb_unicode_general_category_t = 8;
pub const HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER: hb_unicode_general_category_t = 9;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK: hb_unicode_general_category_t = 10;
pub const HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK: hb_unicode_general_category_t = 11;
pub const HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK: hb_unicode_general_category_t = 12;
pub const HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER: hb_unicode_general_category_t = 13;
pub const HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER: hb_unicode_general_category_t = 14;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER: hb_unicode_general_category_t = 15;
pub const HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION: hb_unicode_general_category_t = 16;
pub const HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION: hb_unicode_general_category_t = 17;
pub const HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION: hb_unicode_general_category_t = 18;
pub const HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION: hb_unicode_general_category_t = 19;
pub const HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION: hb_unicode_general_category_t = 20;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION: hb_unicode_general_category_t = 21;
pub const HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION: hb_unicode_general_category_t = 22;
pub const HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL: hb_unicode_general_category_t = 23;
pub const HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL: hb_unicode_general_category_t = 24;
pub const HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL: hb_unicode_general_category_t = 25;
pub const HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL: hb_unicode_general_category_t = 26;
pub const HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR: hb_unicode_general_category_t = 27;
pub const HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR: hb_unicode_general_category_t = 28;
pub const HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR: hb_unicode_general_category_t = 29;
#[doc = " hb_unicode_general_category_t:\n @HB_UNICODE_GENERAL_CATEGORY_CONTROL:              [Cc]\n @HB_UNICODE_GENERAL_CATEGORY_FORMAT:\t\t      [Cf]\n @HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED:\t      [Cn]\n @HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE:\t      [Co]\n @HB_UNICODE_GENERAL_CATEGORY_SURROGATE:\t      [Cs]\n @HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER:     [Ll]\n @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER:      [Lm]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER:\t      [Lo]\n @HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER:     [Lt]\n @HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER:     [Lu]\n @HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK:\t      [Mc]\n @HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK:\t      [Me]\n @HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK:     [Mn]\n @HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER:\t      [Nd]\n @HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER:\t      [Nl]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER:\t      [No]\n @HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION:  [Pc]\n @HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION:     [Pd]\n @HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION:    [Pe]\n @HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION:    [Pf]\n @HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION:  [Pi]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION:    [Po]\n @HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION:     [Ps]\n @HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL:      [Sc]\n @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL:      [Sk]\n @HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL:\t      [Sm]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL:\t      [So]\n @HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR:\t      [Zl]\n @HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR:  [Zp]\n @HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR:      [Zs]\n\n Data type for the \"General_Category\" (gc) property from\n the Unicode Character Database."]
pub type hb_unicode_general_category_t = ::std::os::raw::c_uint;
pub const HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: hb_unicode_combining_class_t = 0;
pub const HB_UNICODE_COMBINING_CLASS_OVERLAY: hb_unicode_combining_class_t = 1;
pub const HB_UNICODE_COMBINING_CLASS_NUKTA: hb_unicode_combining_class_t = 7;
pub const HB_UNICODE_COMBINING_CLASS_KANA_VOICING: hb_unicode_combining_class_t = 8;
pub const HB_UNICODE_COMBINING_CLASS_VIRAMA: hb_unicode_combining_class_t = 9;
pub const HB_UNICODE_COMBINING_CLASS_CCC10: hb_unicode_combining_class_t = 10;
pub const HB_UNICODE_COMBINING_CLASS_CCC11: hb_unicode_combining_class_t = 11;
pub const HB_UNICODE_COMBINING_CLASS_CCC12: hb_unicode_combining_class_t = 12;
pub const HB_UNICODE_COMBINING_CLASS_CCC13: hb_unicode_combining_class_t = 13;
pub const HB_UNICODE_COMBINING_CLASS_CCC14: hb_unicode_combining_class_t = 14;
pub const HB_UNICODE_COMBINING_CLASS_CCC15: hb_unicode_combining_class_t = 15;
pub const HB_UNICODE_COMBINING_CLASS_CCC16: hb_unicode_combining_class_t = 16;
pub const HB_UNICODE_COMBINING_CLASS_CCC17: hb_unicode_combining_class_t = 17;
pub const HB_UNICODE_COMBINING_CLASS_CCC18: hb_unicode_combining_class_t = 18;
pub const HB_UNICODE_COMBINING_CLASS_CCC19: hb_unicode_combining_class_t = 19;
pub const HB_UNICODE_COMBINING_CLASS_CCC20: hb_unicode_combining_class_t = 20;
pub const HB_UNICODE_COMBINING_CLASS_CCC21: hb_unicode_combining_class_t = 21;
pub const HB_UNICODE_COMBINING_CLASS_CCC22: hb_unicode_combining_class_t = 22;
pub const HB_UNICODE_COMBINING_CLASS_CCC23: hb_unicode_combining_class_t = 23;
pub const HB_UNICODE_COMBINING_CLASS_CCC24: hb_unicode_combining_class_t = 24;
pub const HB_UNICODE_COMBINING_CLASS_CCC25: hb_unicode_combining_class_t = 25;
pub const HB_UNICODE_COMBINING_CLASS_CCC26: hb_unicode_combining_class_t = 26;
pub const HB_UNICODE_COMBINING_CLASS_CCC27: hb_unicode_combining_class_t = 27;
pub const HB_UNICODE_COMBINING_CLASS_CCC28: hb_unicode_combining_class_t = 28;
pub const HB_UNICODE_COMBINING_CLASS_CCC29: hb_unicode_combining_class_t = 29;
pub const HB_UNICODE_COMBINING_CLASS_CCC30: hb_unicode_combining_class_t = 30;
pub const HB_UNICODE_COMBINING_CLASS_CCC31: hb_unicode_combining_class_t = 31;
pub const HB_UNICODE_COMBINING_CLASS_CCC32: hb_unicode_combining_class_t = 32;
pub const HB_UNICODE_COMBINING_CLASS_CCC33: hb_unicode_combining_class_t = 33;
pub const HB_UNICODE_COMBINING_CLASS_CCC34: hb_unicode_combining_class_t = 34;
pub const HB_UNICODE_COMBINING_CLASS_CCC35: hb_unicode_combining_class_t = 35;
pub const HB_UNICODE_COMBINING_CLASS_CCC36: hb_unicode_combining_class_t = 36;
pub const HB_UNICODE_COMBINING_CLASS_CCC84: hb_unicode_combining_class_t = 84;
pub const HB_UNICODE_COMBINING_CLASS_CCC91: hb_unicode_combining_class_t = 91;
pub const HB_UNICODE_COMBINING_CLASS_CCC103: hb_unicode_combining_class_t = 103;
pub const HB_UNICODE_COMBINING_CLASS_CCC107: hb_unicode_combining_class_t = 107;
pub const HB_UNICODE_COMBINING_CLASS_CCC118: hb_unicode_combining_class_t = 118;
pub const HB_UNICODE_COMBINING_CLASS_CCC122: hb_unicode_combining_class_t = 122;
pub const HB_UNICODE_COMBINING_CLASS_CCC129: hb_unicode_combining_class_t = 129;
pub const HB_UNICODE_COMBINING_CLASS_CCC130: hb_unicode_combining_class_t = 130;
pub const HB_UNICODE_COMBINING_CLASS_CCC133: hb_unicode_combining_class_t = 132;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: hb_unicode_combining_class_t = 200;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: hb_unicode_combining_class_t = 202;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: hb_unicode_combining_class_t = 214;
pub const HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: hb_unicode_combining_class_t = 216;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: hb_unicode_combining_class_t = 218;
pub const HB_UNICODE_COMBINING_CLASS_BELOW: hb_unicode_combining_class_t = 220;
pub const HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: hb_unicode_combining_class_t = 222;
pub const HB_UNICODE_COMBINING_CLASS_LEFT: hb_unicode_combining_class_t = 224;
pub const HB_UNICODE_COMBINING_CLASS_RIGHT: hb_unicode_combining_class_t = 226;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: hb_unicode_combining_class_t = 228;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE: hb_unicode_combining_class_t = 230;
pub const HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: hb_unicode_combining_class_t = 232;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: hb_unicode_combining_class_t = 233;
pub const HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: hb_unicode_combining_class_t = 234;
pub const HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: hb_unicode_combining_class_t = 240;
pub const HB_UNICODE_COMBINING_CLASS_INVALID: hb_unicode_combining_class_t = 255;
#[doc = " hb_unicode_combining_class_t:\n @HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: Spacing and enclosing marks; also many vowel and consonant signs, even if nonspacing\n @HB_UNICODE_COMBINING_CLASS_OVERLAY: Marks which overlay a base letter or symbol\n @HB_UNICODE_COMBINING_CLASS_NUKTA: Diacritic nukta marks in Brahmi-derived scripts\n @HB_UNICODE_COMBINING_CLASS_KANA_VOICING: Hiragana/Katakana voicing marks\n @HB_UNICODE_COMBINING_CLASS_VIRAMA: Viramas\n @HB_UNICODE_COMBINING_CLASS_CCC10: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC11: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC12: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC13: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC14: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC15: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC16: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC17: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC18: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC19: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC20: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC21: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC22: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC23: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC24: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC25: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC26: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC27: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC28: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC29: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC30: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC31: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC32: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC33: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC34: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC35: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC36: [Syriac]\n @HB_UNICODE_COMBINING_CLASS_CCC84: [Telugu]\n @HB_UNICODE_COMBINING_CLASS_CCC91: [Telugu]\n @HB_UNICODE_COMBINING_CLASS_CCC103: [Thai]\n @HB_UNICODE_COMBINING_CLASS_CCC107: [Thai]\n @HB_UNICODE_COMBINING_CLASS_CCC118: [Lao]\n @HB_UNICODE_COMBINING_CLASS_CCC122: [Lao]\n @HB_UNICODE_COMBINING_CLASS_CCC129: [Tibetan]\n @HB_UNICODE_COMBINING_CLASS_CCC130: [Tibetan]\n @HB_UNICODE_COMBINING_CLASS_CCC133: [Tibetan]\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: Marks attached at the bottom left\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: Marks attached directly below\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: Marks attached directly above\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: Marks attached at the top right\n @HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: Distinct marks at the bottom left\n @HB_UNICODE_COMBINING_CLASS_BELOW: Distinct marks directly below\n @HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: Distinct marks at the bottom right\n @HB_UNICODE_COMBINING_CLASS_LEFT: Distinct marks to the left\n @HB_UNICODE_COMBINING_CLASS_RIGHT: Distinct marks to the right\n @HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: Distinct marks at the top left\n @HB_UNICODE_COMBINING_CLASS_ABOVE: Distinct marks directly above\n @HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: Distinct marks at the top right\n @HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: Distinct marks subtending two bases\n @HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: Distinct marks extending above two bases\n @HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: Greek iota subscript only\n @HB_UNICODE_COMBINING_CLASS_INVALID: Invalid combining class\n\n Data type for the Canonical_Combining_Class (ccc) property\n from the Unicode Character Database.\n\n <note>Note: newer versions of Unicode may add new values.\n Client programs should be ready to handle any value in the 0..254 range\n being returned from hb_unicode_combining_class().</note>\n"]
pub type hb_unicode_combining_class_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_unicode_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_unicode_funcs_get_default() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_create(parent: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_empty() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_reference(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_destroy(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_set_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_unicode_funcs_make_immutable(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_is_immutable(ufuncs: *mut hb_unicode_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_parent(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
#[doc = " hb_unicode_combining_class_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Canonical Combining Class (ccc)\n property for a specified Unicode code point.\n\n Return value: The #hb_unicode_combining_class_t of @unicode\n"]
pub type hb_unicode_combining_class_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_combining_class_t,
>;
#[doc = " hb_unicode_general_category_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the General Category property for\n a specified Unicode code point.\n\n Return value: The #hb_unicode_general_category_t of @unicode\n"]
pub type hb_unicode_general_category_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_general_category_t,
>;
#[doc = " hb_unicode_mirroring_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Bi-Directional Mirroring Glyph\n code point for a specified Unicode code point.\n\n <note>Note: If a code point does not have a specified\n Bi-Directional Mirroring Glyph defined, the method should\n return the original code point.</note>\n\n Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode\n"]
pub type hb_unicode_mirroring_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_codepoint_t,
>;
#[doc = " hb_unicode_script_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Script property for a\n specified Unicode code point.\n\n Return value: The #hb_script_t of @unicode\n"]
pub type hb_unicode_script_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_script_t,
>;
#[doc = " hb_unicode_compose_func_t:\n @ufuncs: A Unicode-functions structure\n @a: The first code point to compose\n @b: The second code point to compose\n @ab: (out): The composed code point\n @user_data: user data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should compose a sequence of two input Unicode code\n points by canonical equivalence, returning the composed code\n point in a #hb_codepoint_t output parameter (if successful).\n The method must return an #hb_bool_t indicating the success\n of the composition.\n\n Return value: True is @a,@b composed, false otherwise\n"]
pub type hb_unicode_compose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_unicode_decompose_func_t:\n @ufuncs: A Unicode-functions structure\n @ab: The code point to decompose\n @a: (out): The first decomposed code point\n @b: (out): The second decomposed code point\n @user_data: user data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should decompose an input Unicode code point,\n returning the two decomposed code points in #hb_codepoint_t\n output parameters (if successful). The method must return an\n #hb_bool_t indicating the success of the composition.\n\n Return value: True if @ab decomposed, false otherwise\n"]
pub type hb_unicode_decompose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_combining_class_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_combining_class_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_combining_class_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_combining_class_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_general_category_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_general_category_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_general_category_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_general_category_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_mirroring_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_mirroring_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_mirroring_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_mirroring_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_script_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_script_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_script_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_script_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_compose_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_compose_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_compose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_compose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_decompose_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_decompose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_combining_class:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the Canonical Combining Class (ccc) property\n of code point @unicode.\n\n Return value: The #hb_unicode_combining_class_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_combining_class(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_combining_class_t;
}
extern "C" {
    #[doc = " hb_unicode_general_category:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the General Category (gc) property\n of code point @unicode.\n\n Return value: The #hb_unicode_general_category_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_general_category(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_general_category_t;
}
extern "C" {
    #[doc = " hb_unicode_mirroring:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the Bi-directional Mirroring Glyph code\n point defined for code point @unicode.\n\n Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_mirroring(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_codepoint_t;
}
extern "C" {
    #[doc = " hb_unicode_script:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the #hb_script_t script to which code\n point @unicode belongs.\n\n Return value: The #hb_script_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_script(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_script_t;
}
extern "C" {
    #[doc = " hb_unicode_compose:\n @ufuncs: The Unicode-functions structure\n @a: The first code point to compose\n @b: The second code point to compose\n @ab: (out): The composed code point\n\n Composes the code point sequence @a,@b by canonical equivalence into\n code point @ab.\n\n Return value: True is @a,@b composed, false otherwise\n\n Since: 0.9.2"]
    pub fn hb_unicode_compose(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    #[doc = " hb_unicode_decompose:\n @ufuncs: The Unicode-functions structure\n @ab: The code point to decompose\n @a: (out): The first decomposed code point\n @b: (out): The second decomposed code point\n\n Decomposes code point @ab by canonical equivalence, into code points\n @a and @b.\n\n Return value: True if @ab decomposed, false otherwise\n\n Since: 0.9.2"]
    pub fn hb_unicode_decompose(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_set_create() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_get_empty() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_reference(set: *mut hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_destroy(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_set_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_get_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_set_allocation_successful(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_clear(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_empty(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_has(set: *const hb_set_t, codepoint: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_add(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_is_equal(set: *const hb_set_t, other: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_is_subset(set: *const hb_set_t, larger_set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_set(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_union(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_intersect(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_subtract(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_symmetric_difference(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_get_population(set: *const hb_set_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_get_min(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_get_max(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_next(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_count(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_face_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_face_create(blob: *mut hb_blob_t, index: ::std::os::raw::c_uint) -> *mut hb_face_t;
}
pub type hb_reference_table_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut hb_blob_t,
>;
extern "C" {
    pub fn hb_face_create_for_tables(
        reference_table_func: hb_reference_table_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_get_empty() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_reference(face: *mut hb_face_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_destroy(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_set_user_data(
        face: *mut hb_face_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_get_user_data(
        face: *const hb_face_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_face_make_immutable(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_is_immutable(face: *const hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_reference_table(face: *const hb_face_t, tag: hb_tag_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_reference_blob(face: *mut hb_face_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_set_index(face: *mut hb_face_t, index: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_index(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_upem(face: *mut hb_face_t, upem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_upem(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_glyph_count(face: *mut hb_face_t, glyph_count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_glyph_count(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_get_table_tags(
        face: *const hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        table_count: *mut ::std::os::raw::c_uint,
        table_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_collect_unicodes(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_variation_selectors(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_variation_unicodes(
        face: *mut hb_face_t,
        variation_selector: hb_codepoint_t,
        out: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_face_builder_create() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_builder_add_table(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        blob: *mut hb_blob_t,
    ) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_font_funcs_create() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_get_empty() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_reference(ffuncs: *mut hb_font_funcs_t) -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_destroy(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_set_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_funcs_get_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_funcs_make_immutable(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_is_immutable(ffuncs: *mut hb_font_funcs_t) -> hb_bool_t;
}
#[doc = " hb_font_extents_t:\n @ascender: The height of typographic ascenders.\n @descender: The depth of typographic descenders.\n @line_gap: The suggested line-spacing gap.\n\n Font-wide extent values, measured in font units.\n\n Note that typically @ascender is positive and @descender\n negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_extents_t {
    pub ascender: hb_position_t,
    pub descender: hb_position_t,
    pub line_gap: hb_position_t,
    pub reserved9: hb_position_t,
    pub reserved8: hb_position_t,
    pub reserved7: hb_position_t,
    pub reserved6: hb_position_t,
    pub reserved5: hb_position_t,
    pub reserved4: hb_position_t,
    pub reserved3: hb_position_t,
    pub reserved2: hb_position_t,
    pub reserved1: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_font_extents_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_font_extents_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_font_extents_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_font_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_gap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(line_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved9) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " hb_glyph_extents_t:\n @x_bearing: Distance from the x-origin to the left extremum of the glyph.\n @y_bearing: Distance from the top extremum of the glyph to the y-origin.\n @width: Distance from the left extremum of the glyph to the right extremum.\n @height: Distance from the top extremum of the glyph to the bottom extremum.\n\n Glyph extent values, measured in font units.\n\n Note that @height is negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_extents_t {
    pub x_bearing: hb_position_t,
    pub y_bearing: hb_position_t,
    pub width: hb_position_t,
    pub height: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_extents_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_extents_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_extents_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_bearing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(x_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_bearing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(y_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(height)
        )
    );
}
pub type hb_font_get_font_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        extents: *mut hb_font_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_font_h_extents_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a font, in horizontal-direction\n text segments. Extents must be returned in an #hb_glyph_extents output\n parameter.\n"]
pub type hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_font_v_extents_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a font, in vertical-direction\n text segments. Extents must be returned in an #hb_glyph_extents output\n parameter.\n"]
pub type hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_nominal_glyph_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the nominal glyph ID for a specified Unicode code\n point. Glyph IDs must be returned in a #hb_codepoint_t output parameter.\n"]
pub type hb_font_get_nominal_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_variation_glyph_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph ID for a specified Unicode code point\n followed by a specified Variation Selector code point. Glyph IDs must be\n returned in a #hb_codepoint_t output parameter.\n"]
pub type hb_font_get_variation_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_nominal_glyphs_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the nominal glyph IDs for a sequence of\n Unicode code points. Glyph IDs must be returned in a #hb_codepoint_t\n output parameter.\n"]
pub type hb_font_get_nominal_glyphs_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
#[doc = " hb_font_get_glyph_advance_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph. The\n method must return an #hb_position_t.\n"]
pub type hb_font_get_glyph_advance_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
#[doc = " hb_font_get_glyph_h_advance_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph, in\n horizontal-direction text segments. Advances must be returned in\n an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_h_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_v_advance_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph, in\n vertical-direction text segments. Advances must be returned in\n an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_v_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_advances_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs.\n"]
pub type hb_font_get_glyph_advances_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_font_get_glyph_h_advances_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs, in\n horizontal-direction text segments.\n"]
pub type hb_font_get_glyph_h_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_v_advances_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs, in\n vertical-direction text segments.\n"]
pub type hb_font_get_glyph_v_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_origin_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph. Each coordinate must be returned in an #hb_position_t\n output parameter.\n"]
pub type hb_font_get_glyph_origin_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_h_origin_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph, in horizontal-direction text segments. Each\n coordinate must be returned in an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
#[doc = " hb_font_get_glyph_v_origin_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph, in vertical-direction text segments. Each coordinate\n must be returned in an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
pub type hb_font_get_glyph_kerning_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
pub type hb_font_get_glyph_h_kerning_func_t = hb_font_get_glyph_kerning_func_t;
#[doc = " hb_font_get_glyph_extents_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a specified glyph. Extents must be\n returned in an #hb_glyph_extents output parameter.\n"]
pub type hb_font_get_glyph_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_contour_point_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) for a\n specified contour point in a glyph. Each coordinate must be returned as\n an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_contour_point_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_name_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph name that corresponds to a\n glyph ID. The name should be returned in a string output parameter.\n"]
pub type hb_font_get_glyph_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_from_name_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph ID that corresponds to a glyph-name\n string.\n"]
pub type hb_font_get_glyph_from_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    #[doc = " hb_font_funcs_set_font_h_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_font_h_extents_func_t.\n\n Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_h_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_h_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_font_v_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_font_v_extents_func_t.\n\n Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_v_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_v_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_nominal_glyph_func_t.\n\n Since: 1.2.3"]
    pub fn hb_font_funcs_set_nominal_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyphs_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_nominal_glyphs_func_t.\n\n Since: 2.0.0"]
    pub fn hb_font_funcs_set_nominal_glyphs_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyphs_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_variation_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_variation_glyph_func_t.\n\n Since: 1.2.3"]
    pub fn hb_font_funcs_set_variation_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_variation_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advance_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_advance_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advance_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_advance_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advances_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_advances_func_t.\n\n Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_h_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advances_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_advances_func_t.\n\n Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_v_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_origin_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_origin_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_origin_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_origin_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_kerning_func:\n @ffuncs: font functions.\n @func: (closure user_data) (destroy destroy) (scope notified):\n @user_data:\n @destroy:\n\n\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_extents_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_contour_point_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_contour_point_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_contour_point_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_contour_point_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_name_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_name_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_from_name_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (optional): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_from_name_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_from_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_from_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_h_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_v_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_variation_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyphs(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_h_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_kerning(
        font: *mut hb_font_t,
        left_glyph: hb_codepoint_t,
        right_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_extents(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_name(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_from_name(
        font: *mut hb_font_t,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_extents_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        extents: *mut hb_font_extents_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advance_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advances_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_add_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_subtract_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_kerning_for_direction(
        font: *mut hb_font_t,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_extents_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_glyph_to_string(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_glyph_from_string(
        font: *mut hb_font_t,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_create(face: *mut hb_face_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_create_sub_font(parent: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_get_empty() -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_reference(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_destroy(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_make_immutable(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_is_immutable(font: *mut hb_font_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_set_parent(font: *mut hb_font_t, parent: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_get_parent(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_set_face(font: *mut hb_font_t, face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_font_get_face(font: *mut hb_font_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_font_set_funcs(
        font: *mut hb_font_t,
        klass: *mut hb_font_funcs_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_funcs_data(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_scale(
        font: *mut hb_font_t,
        x_scale: ::std::os::raw::c_int,
        y_scale: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_get_scale(
        font: *mut hb_font_t,
        x_scale: *mut ::std::os::raw::c_int,
        y_scale: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_set_ppem(
        font: *mut hb_font_t,
        x_ppem: ::std::os::raw::c_uint,
        y_ppem: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_ppem(
        font: *mut hb_font_t,
        x_ppem: *mut ::std::os::raw::c_uint,
        y_ppem: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_ptem(font: *mut hb_font_t, ptem: ::std::os::raw::c_float);
}
extern "C" {
    pub fn hb_font_get_ptem(font: *mut hb_font_t) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_font_set_variations(
        font: *mut hb_font_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_var_coords_design(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_float,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_var_coords_normalized(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_normalized(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn hb_font_set_var_named_instance(
        font: *mut hb_font_t,
        instance_index: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_glyph_info_t:\n @codepoint: either a Unicode code point (before shaping) or a glyph index\n             (after shaping).\n @cluster: the index of the character in the original text that corresponds\n           to this #hb_glyph_info_t, or whatever the client passes to\n           hb_buffer_add(). More than one #hb_glyph_info_t can have the same\n           @cluster value, if they resulted from the same character (e.g. one\n           to many glyph substitution), and when more than one character gets\n           merged in the same glyph (e.g. many to one glyph substitution) the\n           #hb_glyph_info_t will have the smallest cluster value of them.\n           By default some characters are merged into the same cluster\n           (e.g. combining marks have the same cluster as their bases)\n           even if they are separate glyphs, hb_buffer_set_cluster_level()\n           allow selecting more fine-grained cluster handling.\n\n The #hb_glyph_info_t is the structure that holds information about the\n glyphs and their relation to input text."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_info_t {
    pub codepoint: hb_codepoint_t,
    pub mask: hb_mask_t,
    pub cluster: u32,
    pub var1: hb_var_int_t,
    pub var2: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_info_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codepoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(codepoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cluster) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var2)
        )
    );
}
pub const HB_GLYPH_FLAG_UNSAFE_TO_BREAK: hb_glyph_flags_t = 1;
pub const HB_GLYPH_FLAG_DEFINED: hb_glyph_flags_t = 1;
#[doc = " hb_glyph_flags_t:\n @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the\n \t\t\t\t   beginning of the cluster this glyph is part of,\n \t\t\t\t   then both sides need to be re-shaped, as the\n \t\t\t\t   result might be different.  On the flip side,\n \t\t\t\t   it means that when this flag is not present,\n \t\t\t\t   then it's safe to break the glyph-run at the\n \t\t\t\t   beginning of this cluster, and the two sides\n \t\t\t\t   represent the exact same result one would get\n \t\t\t\t   if breaking input text at the beginning of\n \t\t\t\t   this cluster and shaping the two sides\n \t\t\t\t   separately.  This can be used to optimize\n \t\t\t\t   paragraph layout, by avoiding re-shaping\n \t\t\t\t   of each line after line-breaking, or limiting\n \t\t\t\t   the reshaping to a small piece around the\n \t\t\t\t   breaking point only.\n @HB_GLYPH_FLAG_DEFINED: All the currently defined flags.\n\n Since: 1.5.0"]
pub type hb_glyph_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_glyph_info_get_glyph_flags(info: *const hb_glyph_info_t) -> hb_glyph_flags_t;
}
#[doc = " hb_glyph_position_t:\n @x_advance: how much the line advances after drawing this glyph when setting\n             text in horizontal direction.\n @y_advance: how much the line advances after drawing this glyph when setting\n             text in vertical direction.\n @x_offset: how much the glyph moves on the X-axis before drawing it, this\n            should not affect how much the line advances.\n @y_offset: how much the glyph moves on the Y-axis before drawing it, this\n            should not affect how much the line advances.\n\n The #hb_glyph_position_t is the structure that holds the positions of the\n glyph in both horizontal and vertical directions. All positions in\n #hb_glyph_position_t are relative to the current point.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_position_t {
    pub x_advance: hb_position_t,
    pub y_advance: hb_position_t,
    pub x_offset: hb_position_t,
    pub y_offset: hb_position_t,
    pub var: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_position_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_position_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_position_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_position_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_advance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_advance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(var)
        )
    );
}
#[doc = " hb_segment_properties_t:\n @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction().\n @script: the #hb_script_t of the buffer, see hb_buffer_set_script().\n @language: the #hb_language_t of the buffer, see hb_buffer_set_language().\n\n The structure that holds various text properties of an #hb_buffer_t. Can be\n set and retrieved using hb_buffer_set_segment_properties() and\n hb_buffer_get_segment_properties(), respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_segment_properties_t {
    pub direction: hb_direction_t,
    pub script: hb_script_t,
    pub language: hb_language_t,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_segment_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_segment_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_segment_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_segment_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).script) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).language) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved2)
        )
    );
}
extern "C" {
    pub fn hb_segment_properties_equal(
        a: *const hb_segment_properties_t,
        b: *const hb_segment_properties_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_segment_properties_hash(p: *const hb_segment_properties_t) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_buffer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_buffer_create() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_get_empty() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reference(buffer: *mut hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_destroy(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_set_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub const HB_BUFFER_CONTENT_TYPE_INVALID: hb_buffer_content_type_t = 0;
pub const HB_BUFFER_CONTENT_TYPE_UNICODE: hb_buffer_content_type_t = 1;
pub const HB_BUFFER_CONTENT_TYPE_GLYPHS: hb_buffer_content_type_t = 2;
#[doc = " hb_buffer_content_type_t:\n @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer.\n @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping).\n @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping)."]
pub type hb_buffer_content_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_content_type(
        buffer: *mut hb_buffer_t,
        content_type: hb_buffer_content_type_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_content_type(buffer: *mut hb_buffer_t) -> hb_buffer_content_type_t;
}
extern "C" {
    pub fn hb_buffer_set_unicode_funcs(
        buffer: *mut hb_buffer_t,
        unicode_funcs: *mut hb_unicode_funcs_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_unicode_funcs(buffer: *mut hb_buffer_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_buffer_set_direction(buffer: *mut hb_buffer_t, direction: hb_direction_t);
}
extern "C" {
    pub fn hb_buffer_get_direction(buffer: *mut hb_buffer_t) -> hb_direction_t;
}
extern "C" {
    pub fn hb_buffer_set_script(buffer: *mut hb_buffer_t, script: hb_script_t);
}
extern "C" {
    pub fn hb_buffer_get_script(buffer: *mut hb_buffer_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_buffer_set_language(buffer: *mut hb_buffer_t, language: hb_language_t);
}
extern "C" {
    pub fn hb_buffer_get_language(buffer: *mut hb_buffer_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_buffer_set_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *const hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *mut hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_guess_segment_properties(buffer: *mut hb_buffer_t);
}
pub const HB_BUFFER_FLAG_DEFAULT: hb_buffer_flags_t = 0;
pub const HB_BUFFER_FLAG_BOT: hb_buffer_flags_t = 1;
pub const HB_BUFFER_FLAG_EOT: hb_buffer_flags_t = 2;
pub const HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 4;
pub const HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 8;
pub const HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE: hb_buffer_flags_t = 16;
#[doc = " hb_buffer_flags_t:\n @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.\n @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning\n                      of text paragraph can be applied to this buffer. Should usually\n                      be set, unless you are passing to the buffer only part\n                      of the text without the full context.\n @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text\n                      paragraph can be applied to this buffer, similar to\n                      @HB_BUFFER_FLAG_BOT.\n @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:\n                      flag indication that character with Default_Ignorable\n                      Unicode property should use the corresponding glyph\n                      from the font, instead of hiding them (done by\n                      replacing them with the space glyph and zeroing the\n                      advance width.)  This flag takes precedence over\n                      @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES.\n @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES:\n                      flag indication that character with Default_Ignorable\n                      Unicode property should be removed from glyph string\n                      instead of hiding them (done by replacing them with the\n                      space glyph and zeroing the advance width.)\n                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes\n                      precedence over this flag. Since: 1.8.0\n @HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE:\n                      flag indicating that a dotted circle should\n                      not be inserted in the rendering of incorrect\n                      character sequences (such at <0905 093E>). Since: 2.4\n\n Since: 0.9.20"]
pub type hb_buffer_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_flags(buffer: *mut hb_buffer_t, flags: hb_buffer_flags_t);
}
extern "C" {
    pub fn hb_buffer_get_flags(buffer: *mut hb_buffer_t) -> hb_buffer_flags_t;
}
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: hb_buffer_cluster_level_t = 0;
pub const HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: hb_buffer_cluster_level_t = 1;
pub const HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: hb_buffer_cluster_level_t = 2;
pub const HB_BUFFER_CLUSTER_LEVEL_DEFAULT: hb_buffer_cluster_level_t = 0;
#[doc = " hb_buffer_cluster_level_t:\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: Return cluster values grouped by graphemes into\n   monotone order.\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: Return cluster values grouped into monotone order.\n @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: Don't group cluster values.\n @HB_BUFFER_CLUSTER_LEVEL_DEFAULT: Default cluster level,\n   equal to @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES.\n\n Data type for holding HarfBuzz's clustering behavior options. The cluster level\n dictates one aspect of how HarfBuzz will treat non-base characters\n during shaping.\n\n In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES, non-base\n characters are merged into the cluster of the base character that precedes them.\n\n In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS, non-base characters are initially\n assigned their own cluster values, which are not merged into preceding base\n clusters. This allows HarfBuzz to perform additional operations like reorder\n sequences of adjacent marks.\n\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES is the default, because it maintains\n backward compatibility with older versions of HarfBuzz. New client programs that\n do not need to maintain such backward compatibility are recommended to use\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS instead of the default.\n\n Since: 0.9.42"]
pub type hb_buffer_cluster_level_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_cluster_level(
        buffer: *mut hb_buffer_t,
        cluster_level: hb_buffer_cluster_level_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_cluster_level(buffer: *mut hb_buffer_t) -> hb_buffer_cluster_level_t;
}
extern "C" {
    pub fn hb_buffer_set_replacement_codepoint(
        buffer: *mut hb_buffer_t,
        replacement: hb_codepoint_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_replacement_codepoint(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_invisible_glyph(buffer: *mut hb_buffer_t, invisible: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_invisible_glyph(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_reset(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_clear_contents(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_pre_allocate(
        buffer: *mut hb_buffer_t,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_allocation_successful(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_reverse(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_reverse_range(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_reverse_clusters(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_add(
        buffer: *mut hb_buffer_t,
        codepoint: hb_codepoint_t,
        cluster: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf8(
        buffer: *mut hb_buffer_t,
        text: *const ::std::os::raw::c_char,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf16(
        buffer: *mut hb_buffer_t,
        text: *const u16,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf32(
        buffer: *mut hb_buffer_t,
        text: *const u32,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_latin1(
        buffer: *mut hb_buffer_t,
        text: *const u8,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_codepoints(
        buffer: *mut hb_buffer_t,
        text: *const hb_codepoint_t,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_append(
        buffer: *mut hb_buffer_t,
        source: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_set_length(
        buffer: *mut hb_buffer_t,
        length: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_length(buffer: *mut hb_buffer_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_get_glyph_infos(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_info_t;
}
extern "C" {
    pub fn hb_buffer_get_glyph_positions(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_position_t;
}
extern "C" {
    pub fn hb_buffer_has_positions(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_normalize_glyphs(buffer: *mut hb_buffer_t);
}
pub const HB_BUFFER_SERIALIZE_FLAG_DEFAULT: hb_buffer_serialize_flags_t = 0;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: hb_buffer_serialize_flags_t = 1;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: hb_buffer_serialize_flags_t = 2;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: hb_buffer_serialize_flags_t = 4;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: hb_buffer_serialize_flags_t = 8;
pub const HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: hb_buffer_serialize_flags_t = 16;
pub const HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: hb_buffer_serialize_flags_t = 32;
#[doc = " hb_buffer_serialize_flags_t:\n @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.\n @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.\n @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.\n @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.\n @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.\n @HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: serialize glyph flags. Since: 1.5.0\n @HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: do not serialize glyph advances,\n  glyph offsets will reflect absolute glyph positions. Since: 1.8.0\n\n Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().\n\n Since: 0.9.20"]
pub type hb_buffer_serialize_flags_t = ::std::os::raw::c_uint;
pub const HB_BUFFER_SERIALIZE_FORMAT_TEXT: hb_buffer_serialize_format_t = 1413830740;
pub const HB_BUFFER_SERIALIZE_FORMAT_JSON: hb_buffer_serialize_format_t = 1246973774;
pub const HB_BUFFER_SERIALIZE_FORMAT_INVALID: hb_buffer_serialize_format_t = 0;
#[doc = " hb_buffer_serialize_format_t:\n @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format.\n @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format.\n @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format.\n\n The buffer serialization and de-serialization format used in\n hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().\n\n Since: 0.9.2"]
pub type hb_buffer_serialize_format_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_serialize_format_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_buffer_serialize_format_t;
}
extern "C" {
    pub fn hb_buffer_serialize_format_to_string(
        format: hb_buffer_serialize_format_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_list_formats() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_glyphs(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize_unicode(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_deserialize_glyphs(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_deserialize_unicode(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
pub const HB_BUFFER_DIFF_FLAG_EQUAL: hb_buffer_diff_flags_t = 0;
pub const HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: hb_buffer_diff_flags_t = 1;
pub const HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: hb_buffer_diff_flags_t = 2;
pub const HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: hb_buffer_diff_flags_t = 4;
pub const HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: hb_buffer_diff_flags_t = 8;
pub const HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: hb_buffer_diff_flags_t = 16;
pub const HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: hb_buffer_diff_flags_t = 32;
pub const HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: hb_buffer_diff_flags_t = 64;
pub const HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: hb_buffer_diff_flags_t = 128;
pub type hb_buffer_diff_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_diff(
        buffer: *mut hb_buffer_t,
        reference: *mut hb_buffer_t,
        dottedcircle_glyph: hb_codepoint_t,
        position_fuzz: ::std::os::raw::c_uint,
    ) -> hb_buffer_diff_flags_t;
}
pub type hb_buffer_message_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut hb_buffer_t,
        font: *mut hb_font_t,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_buffer_set_message_func(
        buffer: *mut hb_buffer_t,
        func: hb_buffer_message_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
pub type hb_font_get_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_font_funcs_set_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_set_invert(set: *mut hb_set_t);
}
#[doc = " hb_unicode_eastasian_width_func_t:\n\n Deprecated: 2.0.0"]
pub type hb_unicode_eastasian_width_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_eastasian_width_func:\n @ufuncs: a Unicode function structure\n @func: (closure user_data) (destroy destroy) (scope notified):\n @user_data:\n @destroy:\n\n\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_eastasian_width_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_eastasian_width_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_eastasian_width:\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_eastasian_width(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " hb_unicode_decompose_compatibility_func_t:\n @ufuncs: a Unicode function structure\n @u: codepoint to decompose\n @decomposed: address of codepoint array (of length %HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into\n @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()\n\n Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.\n The complete length of the decomposition will be returned.\n\n If @u has no compatibility decomposition, zero should be returned.\n\n The Unicode standard guarantees that a buffer of length %HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any\n compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations\n of this function type must ensure that they do not write past the provided array.\n\n Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.\n\n Deprecated: 2.0.0"]
pub type hb_unicode_decompose_compatibility_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_compatibility_func:\n @ufuncs: a Unicode function structure\n @func: (closure user_data) (destroy destroy) (scope notified):\n @user_data:\n @destroy:\n\n\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_decompose_compatibility_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_compatibility_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_unicode_decompose_compatibility(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
pub type hb_font_get_glyph_v_kerning_func_t = hb_font_get_glyph_kerning_func_t;
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_kerning_func:\n @ffuncs: font functions.\n @func: (closure user_data) (destroy destroy) (scope notified):\n @user_data:\n @destroy:\n\n\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_font_funcs_set_glyph_v_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_kerning(
        font: *mut hb_font_t,
        top_glyph: hb_codepoint_t,
        bottom_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_map_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_map_create() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_get_empty() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_reference(map: *mut hb_map_t) -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_destroy(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_set_user_data(
        map: *mut hb_map_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_user_data(
        map: *mut hb_map_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_map_allocation_successful(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_clear(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_is_empty(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_population(map: *const hb_map_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_map_set(map: *mut hb_map_t, key: hb_codepoint_t, value: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_get(map: *const hb_map_t, key: hb_codepoint_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_map_del(map: *mut hb_map_t, key: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_has(map: *const hb_map_t, key: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_shape_full(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_list_shapers() -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_shape_plan_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_shape_plan_create(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_get_empty() -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_reference(shape_plan: *mut hb_shape_plan_t) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_destroy(shape_plan: *mut hb_shape_plan_t);
}
extern "C" {
    pub fn hb_shape_plan_set_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_shape_plan_execute(
        shape_plan: *mut hb_shape_plan_t,
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_shaper(
        shape_plan: *mut hb_shape_plan_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        micro: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version_atleast(
        major: ::std::os::raw::c_uint,
        minor: ::std::os::raw::c_uint,
        micro: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
pub type hb_ot_name_id_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_name_entry_t:\n @name_id: name ID\n @language: language\n\n Structure representing a name ID in a particular language.\n\n Since: 2.1.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_ot_name_entry_t {
    pub name_id: hb_ot_name_id_t,
    pub var: hb_var_int_t,
    pub language: hb_language_t,
}
#[test]
fn bindgen_test_layout_hb_ot_name_entry_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_name_entry_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_name_entry_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_ot_name_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_name_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_ot_name_entry_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_name_entry_t),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_name_entry_t),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).language) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_name_entry_t),
            "::",
            stringify!(language)
        )
    );
}
extern "C" {
    pub fn hb_ot_name_list_names(
        face: *mut hb_face_t,
        num_entries: *mut ::std::os::raw::c_uint,
    ) -> *const hb_ot_name_entry_t;
}
extern "C" {
    pub fn hb_ot_name_get_utf8(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_name_get_utf16(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut u16,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_name_get_utf32(
        face: *mut hb_face_t,
        name_id: hb_ot_name_id_t,
        language: hb_language_t,
        text_size: *mut ::std::os::raw::c_uint,
        text: *mut u32,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_palettes(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_palette_get_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_palette_get_name_id(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_color_palette_color_get_name_id(
        face: *mut hb_face_t,
        color_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
pub const HB_OT_COLOR_PALETTE_FLAG_DEFAULT: hb_ot_color_palette_flags_t = 0;
pub const HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND: hb_ot_color_palette_flags_t = 1;
pub const HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND: hb_ot_color_palette_flags_t = 2;
#[doc = " hb_ot_color_palette_flags_t:\n @HB_OT_COLOR_PALETTE_FLAG_DEFAULT: Default indicating that there is nothing special\n   to note about a color palette.\n @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND: Flag indicating that the color\n   palette is appropriate to use when displaying the font on a light background such as white.\n @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND: Flag indicating that the color\n   palette is appropriate to use when displaying the font on a dark background such as black.\n\n Since: 2.1.0"]
pub type hb_ot_color_palette_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_color_palette_get_flags(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
    ) -> hb_ot_color_palette_flags_t;
}
extern "C" {
    pub fn hb_ot_color_palette_get_colors(
        face: *mut hb_face_t,
        palette_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        color_count: *mut ::std::os::raw::c_uint,
        colors: *mut hb_color_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_layers(face: *mut hb_face_t) -> hb_bool_t;
}
#[doc = " hb_ot_color_layer_t:\n\n Pairs of glyph and color index.\n\n Since: 2.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_color_layer_t {
    pub glyph: hb_codepoint_t,
    pub color_index: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_ot_color_layer_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_color_layer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_color_layer_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_color_layer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_color_layer_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_color_layer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_color_layer_t),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_color_layer_t),
            "::",
            stringify!(color_index)
        )
    );
}
extern "C" {
    pub fn hb_ot_color_glyph_get_layers(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        layer_count: *mut ::std::os::raw::c_uint,
        layers: *mut hb_ot_color_layer_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_color_has_svg(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_glyph_reference_svg(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_ot_color_has_png(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_color_glyph_reference_png(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_ot_layout_table_choose_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tags: *const hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
        chosen_script: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_script_find_language(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_tag: hb_tag_t,
        language_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_tags_from_script(
        script: hb_script_t,
        script_tag_1: *mut hb_tag_t,
        script_tag_2: *mut hb_tag_t,
    );
}
extern "C" {
    pub fn hb_ot_tag_from_language(language: hb_language_t) -> hb_tag_t;
}
#[doc = " hb_ot_var_axis_t:\n\n Since: 1.4.2\n Deprecated: 2.2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_var_axis_t {
    pub tag: hb_tag_t,
    pub name_id: hb_ot_name_id_t,
    pub min_value: ::std::os::raw::c_float,
    pub default_value: ::std::os::raw::c_float,
    pub max_value: ::std::os::raw::c_float,
}
#[test]
fn bindgen_test_layout_hb_ot_var_axis_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_var_axis_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_var_axis_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_var_axis_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_var_axis_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_var_axis_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(min_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(max_value)
        )
    );
}
extern "C" {
    pub fn hb_ot_var_get_axes(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        axes_count: *mut ::std::os::raw::c_uint,
        axes_array: *mut hb_ot_var_axis_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_find_axis(
        face: *mut hb_face_t,
        axis_tag: hb_tag_t,
        axis_index: *mut ::std::os::raw::c_uint,
        axis_info: *mut hb_ot_var_axis_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_font_set_funcs(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_ot_tags_from_script_and_language(
        script: hb_script_t,
        language: hb_language_t,
        script_count: *mut ::std::os::raw::c_uint,
        script_tags: *mut hb_tag_t,
        language_count: *mut ::std::os::raw::c_uint,
        language_tags: *mut hb_tag_t,
    );
}
extern "C" {
    pub fn hb_ot_tag_to_script(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_ot_tag_to_language(tag: hb_tag_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_ot_tags_to_script_and_language(
        script_tag: hb_tag_t,
        language_tag: hb_tag_t,
        script: *mut hb_script_t,
        language: *mut hb_language_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_has_glyph_classes(face: *mut hb_face_t) -> hb_bool_t;
}
pub const HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED: hb_ot_layout_glyph_class_t = 0;
pub const HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH: hb_ot_layout_glyph_class_t = 1;
pub const HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE: hb_ot_layout_glyph_class_t = 2;
pub const HB_OT_LAYOUT_GLYPH_CLASS_MARK: hb_ot_layout_glyph_class_t = 3;
pub const HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT: hb_ot_layout_glyph_class_t = 4;
#[doc = " hb_ot_layout_glyph_class_t:\n @HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED: Glyphs not matching the other classifications\n @HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH: Spacing, single characters, capable of accepting marks\n @HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE: Glyphs that represent ligation of multiple characters\n @HB_OT_LAYOUT_GLYPH_CLASS_MARK: Non-spacing, combining glyphs that represent marks\n @HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT: Spacing glyphs that represent part of a single character\n\n The GDEF classes defined for glyphs.\n"]
pub type hb_ot_layout_glyph_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_layout_get_glyph_class(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_ot_layout_glyph_class_t;
}
extern "C" {
    pub fn hb_ot_layout_get_glyphs_in_class(
        face: *mut hb_face_t,
        klass: hb_ot_layout_glyph_class_t,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_get_attach_points(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        point_count: *mut ::std::os::raw::c_uint,
        point_array: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_get_ligature_carets(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        caret_count: *mut ::std::os::raw::c_uint,
        caret_array: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_script_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        script_count: *mut ::std::os::raw::c_uint,
        script_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_find_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tag: hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_select_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_count: ::std::os::raw::c_uint,
        script_tags: *const hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
        chosen_script: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_get_language_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        language_count: *mut ::std::os::raw::c_uint,
        language_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_select_language(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_count: ::std::os::raw::c_uint,
        language_tags: *const hb_tag_t,
        language_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature_index(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
        feature_tag: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_indexes(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_find_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_tag: hb_tag_t,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_lookup_count(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_collect_features(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        scripts: *const hb_tag_t,
        languages: *const hb_tag_t,
        features: *const hb_tag_t,
        feature_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_collect_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        scripts: *const hb_tag_t,
        languages: *const hb_tag_t,
        features: *const hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_lookup_collect_glyphs(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs_before: *mut hb_set_t,
        glyphs_input: *mut hb_set_t,
        glyphs_after: *mut hb_set_t,
        glyphs_output: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_table_find_feature_variations(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        variations_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_with_variations_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        variations_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_has_substitution(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_get_glyph_alternates(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        alternate_count: *mut ::std::os::raw::c_uint,
        alternate_glyphs: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_lookup_would_substitute(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *const hb_codepoint_t,
        glyphs_length: ::std::os::raw::c_uint,
        zero_context: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_substitute_closure(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_lookups_substitute_closure(
        face: *mut hb_face_t,
        lookups: *const hb_set_t,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_has_positioning(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_get_size_params(
        face: *mut hb_face_t,
        design_size: *mut ::std::os::raw::c_uint,
        subfamily_id: *mut ::std::os::raw::c_uint,
        subfamily_name_id: *mut hb_ot_name_id_t,
        range_start: *mut ::std::os::raw::c_uint,
        range_end: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_name_ids(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        label_id: *mut hb_ot_name_id_t,
        tooltip_id: *mut hb_ot_name_id_t,
        sample_id: *mut hb_ot_name_id_t,
        num_named_parameters: *mut ::std::os::raw::c_uint,
        first_param_id: *mut hb_ot_name_id_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_characters(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        char_count: *mut ::std::os::raw::c_uint,
        characters: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
pub const HB_OT_LAYOUT_BASELINE_TAG_ROMAN: hb_ot_layout_baseline_tag_t = 1919905134;
pub const HB_OT_LAYOUT_BASELINE_TAG_HANGING: hb_ot_layout_baseline_tag_t = 1751215719;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT: hb_ot_layout_baseline_tag_t =
    1768121954;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT: hb_ot_layout_baseline_tag_t =
    1768121972;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT: hb_ot_layout_baseline_tag_t =
    1768187247;
pub const HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT: hb_ot_layout_baseline_tag_t =
    1768191088;
pub const HB_OT_LAYOUT_BASELINE_TAG_MATH: hb_ot_layout_baseline_tag_t = 1835103336;
pub const _HB_OT_LAYOUT_BASELINE_TAG_MAX_VALUE: hb_ot_layout_baseline_tag_t = 2147483647;
#[doc = " hb_ot_layout_baseline_tag_t:\n @HB_OT_LAYOUT_BASELINE_TAG_ROMAN: The baseline used by alphabetic scripts such as Latin, Cyrillic and Greek.\n In vertical writing mode, the alphabetic baseline for characters rotated 90 degrees clockwise.\n (This would not apply to alphabetic characters that remain upright in vertical writing mode, since these\n characters are not rotated.)\n @HB_OT_LAYOUT_BASELINE_TAG_HANGING: The hanging baseline. In horizontal direction, this is the horizontal\n line from which syllables seem, to hang in Tibetan and other similar scripts. In vertical writing mode,\n for Tibetan (or some other similar script) characters rotated 90 degrees clockwise.\n @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT: Ideographic character face bottom or left edge,\n if the direction is horizontal or vertical, respectively.\n @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT: Ideographic character face top or right edge,\n if the direction is horizontal or vertical, respectively.\n @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT: Ideographic em-box bottom or left edge,\n if the direction is horizontal or vertical, respectively.\n @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT: Ideographic em-box top or right edge baseline,\n if the direction is horizontal or vertical, respectively.\n @HB_OT_LAYOUT_BASELINE_TAG_MATH: The baseline about which mathematical characters are centered.\n In vertical writing mode when mathematical characters rotated 90 degrees clockwise, are centered.\n\n Baseline tags from https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags\n\n Since: 2.6.0"]
pub type hb_ot_layout_baseline_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_layout_get_baseline(
        font: *mut hb_font_t,
        baseline_tag: hb_ot_layout_baseline_tag_t,
        direction: hb_direction_t,
        script_tag: hb_tag_t,
        language_tag: hb_tag_t,
        coord: *mut hb_position_t,
    ) -> hb_bool_t;
}
pub const HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN: hb_ot_math_constant_t = 0;
pub const HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN: hb_ot_math_constant_t = 1;
pub const HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT: hb_ot_math_constant_t = 2;
pub const HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT: hb_ot_math_constant_t = 3;
pub const HB_OT_MATH_CONSTANT_MATH_LEADING: hb_ot_math_constant_t = 4;
pub const HB_OT_MATH_CONSTANT_AXIS_HEIGHT: hb_ot_math_constant_t = 5;
pub const HB_OT_MATH_CONSTANT_ACCENT_BASE_HEIGHT: hb_ot_math_constant_t = 6;
pub const HB_OT_MATH_CONSTANT_FLATTENED_ACCENT_BASE_HEIGHT: hb_ot_math_constant_t = 7;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_SHIFT_DOWN: hb_ot_math_constant_t = 8;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_TOP_MAX: hb_ot_math_constant_t = 9;
pub const HB_OT_MATH_CONSTANT_SUBSCRIPT_BASELINE_DROP_MIN: hb_ot_math_constant_t = 10;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP: hb_ot_math_constant_t = 11;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP_CRAMPED: hb_ot_math_constant_t = 12;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MIN: hb_ot_math_constant_t = 13;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BASELINE_DROP_MAX: hb_ot_math_constant_t = 14;
pub const HB_OT_MATH_CONSTANT_SUB_SUPERSCRIPT_GAP_MIN: hb_ot_math_constant_t = 15;
pub const HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT: hb_ot_math_constant_t = 16;
pub const HB_OT_MATH_CONSTANT_SPACE_AFTER_SCRIPT: hb_ot_math_constant_t = 17;
pub const HB_OT_MATH_CONSTANT_UPPER_LIMIT_GAP_MIN: hb_ot_math_constant_t = 18;
pub const HB_OT_MATH_CONSTANT_UPPER_LIMIT_BASELINE_RISE_MIN: hb_ot_math_constant_t = 19;
pub const HB_OT_MATH_CONSTANT_LOWER_LIMIT_GAP_MIN: hb_ot_math_constant_t = 20;
pub const HB_OT_MATH_CONSTANT_LOWER_LIMIT_BASELINE_DROP_MIN: hb_ot_math_constant_t = 21;
pub const HB_OT_MATH_CONSTANT_STACK_TOP_SHIFT_UP: hb_ot_math_constant_t = 22;
pub const HB_OT_MATH_CONSTANT_STACK_TOP_DISPLAY_STYLE_SHIFT_UP: hb_ot_math_constant_t = 23;
pub const HB_OT_MATH_CONSTANT_STACK_BOTTOM_SHIFT_DOWN: hb_ot_math_constant_t = 24;
pub const HB_OT_MATH_CONSTANT_STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN: hb_ot_math_constant_t = 25;
pub const HB_OT_MATH_CONSTANT_STACK_GAP_MIN: hb_ot_math_constant_t = 26;
pub const HB_OT_MATH_CONSTANT_STACK_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 27;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_TOP_SHIFT_UP: hb_ot_math_constant_t = 28;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_BOTTOM_SHIFT_DOWN: hb_ot_math_constant_t = 29;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_ABOVE_MIN: hb_ot_math_constant_t = 30;
pub const HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_BELOW_MIN: hb_ot_math_constant_t = 31;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_SHIFT_UP: hb_ot_math_constant_t = 32;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP: hb_ot_math_constant_t = 33;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_SHIFT_DOWN: hb_ot_math_constant_t = 34;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN: hb_ot_math_constant_t =
    35;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_GAP_MIN: hb_ot_math_constant_t = 36;
pub const HB_OT_MATH_CONSTANT_FRACTION_NUM_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 37;
pub const HB_OT_MATH_CONSTANT_FRACTION_RULE_THICKNESS: hb_ot_math_constant_t = 38;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_GAP_MIN: hb_ot_math_constant_t = 39;
pub const HB_OT_MATH_CONSTANT_FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN: hb_ot_math_constant_t = 40;
pub const HB_OT_MATH_CONSTANT_SKEWED_FRACTION_HORIZONTAL_GAP: hb_ot_math_constant_t = 41;
pub const HB_OT_MATH_CONSTANT_SKEWED_FRACTION_VERTICAL_GAP: hb_ot_math_constant_t = 42;
pub const HB_OT_MATH_CONSTANT_OVERBAR_VERTICAL_GAP: hb_ot_math_constant_t = 43;
pub const HB_OT_MATH_CONSTANT_OVERBAR_RULE_THICKNESS: hb_ot_math_constant_t = 44;
pub const HB_OT_MATH_CONSTANT_OVERBAR_EXTRA_ASCENDER: hb_ot_math_constant_t = 45;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_VERTICAL_GAP: hb_ot_math_constant_t = 46;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_RULE_THICKNESS: hb_ot_math_constant_t = 47;
pub const HB_OT_MATH_CONSTANT_UNDERBAR_EXTRA_DESCENDER: hb_ot_math_constant_t = 48;
pub const HB_OT_MATH_CONSTANT_RADICAL_VERTICAL_GAP: hb_ot_math_constant_t = 49;
pub const HB_OT_MATH_CONSTANT_RADICAL_DISPLAY_STYLE_VERTICAL_GAP: hb_ot_math_constant_t = 50;
pub const HB_OT_MATH_CONSTANT_RADICAL_RULE_THICKNESS: hb_ot_math_constant_t = 51;
pub const HB_OT_MATH_CONSTANT_RADICAL_EXTRA_ASCENDER: hb_ot_math_constant_t = 52;
pub const HB_OT_MATH_CONSTANT_RADICAL_KERN_BEFORE_DEGREE: hb_ot_math_constant_t = 53;
pub const HB_OT_MATH_CONSTANT_RADICAL_KERN_AFTER_DEGREE: hb_ot_math_constant_t = 54;
pub const HB_OT_MATH_CONSTANT_RADICAL_DEGREE_BOTTOM_RAISE_PERCENT: hb_ot_math_constant_t = 55;
#[doc = " hb_ot_math_constant_t:\n\n The 'MATH' table constants specified at\n https://docs.microsoft.com/en-us/typography/opentype/spec/math\n\n Since: 1.3.3"]
pub type hb_ot_math_constant_t = ::std::os::raw::c_uint;
pub const HB_OT_MATH_KERN_TOP_RIGHT: hb_ot_math_kern_t = 0;
pub const HB_OT_MATH_KERN_TOP_LEFT: hb_ot_math_kern_t = 1;
pub const HB_OT_MATH_KERN_BOTTOM_RIGHT: hb_ot_math_kern_t = 2;
pub const HB_OT_MATH_KERN_BOTTOM_LEFT: hb_ot_math_kern_t = 3;
#[doc = " hb_ot_math_kern_t:\n\n The math kerning-table types defined for the four corners\n of a glyph.\n\n Since: 1.3.3"]
pub type hb_ot_math_kern_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_math_glyph_variant_t:\n @glyph: The glyph index of the variant\n @advance: The advance width of the variant\n\n Data type to hold math-variant information for a glyph.\n\n Since: 1.3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_variant_t {
    pub glyph: hb_codepoint_t,
    pub advance: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_variant_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_math_glyph_variant_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_variant_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_variant_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_variant_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_variant_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_variant_t),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_variant_t),
            "::",
            stringify!(advance)
        )
    );
}
pub const HB_OT_MATH_GLYPH_PART_FLAG_EXTENDER: hb_ot_math_glyph_part_flags_t = 1;
#[doc = " hb_ot_math_glyph_part_flags_t:\n\n Flags for math glyph parts.\n\n Since: 1.3.3"]
pub type hb_ot_math_glyph_part_flags_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_math_glyph_part_t:\n @glyph: The glyph index of the variant part\n @start_connector_length: The length of the connector on the starting side of the variant part\n @end_connector_length: The length of the connector on the ending side of the variant part\n @full_advance: The total advance of the part\n @flags: #hb_ot_math_glyph_part_flags_t flags for the part\n\n Data type to hold information for a \"part\" component of a math-variant glyph.\n Large variants for stretchable math glyphs (such as parentheses) can be constructed\n on the fly from parts.\n\n Since: 1.3.3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_part_t {
    pub glyph: hb_codepoint_t,
    pub start_connector_length: hb_position_t,
    pub end_connector_length: hb_position_t,
    pub full_advance: hb_position_t,
    pub flags: hb_ot_math_glyph_part_flags_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_part_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_math_glyph_part_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_part_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_part_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_part_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_part_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_connector_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(start_connector_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_connector_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(end_connector_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).full_advance) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(full_advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn hb_ot_math_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_constant(
        font: *mut hb_font_t,
        constant: hb_ot_math_constant_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_italics_correction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_top_accent_attachment(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_is_glyph_extended_shape(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_kerning(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        kern: hb_ot_math_kern_t,
        correction_height: hb_position_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_variants(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        variants_count: *mut ::std::os::raw::c_uint,
        variants: *mut hb_ot_math_glyph_variant_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_math_get_min_connector_overlap(
        font: *mut hb_font_t,
        direction: hb_direction_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_assembly(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        parts_count: *mut ::std::os::raw::c_uint,
        parts: *mut hb_ot_math_glyph_part_t,
        italics_correction: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
pub const HB_OT_META_TAG_DESIGN_LANGUAGES: hb_ot_meta_tag_t = 1684827751;
pub const HB_OT_META_TAG_SUPPORTED_LANGUAGES: hb_ot_meta_tag_t = 1936485991;
pub const _HB_OT_META_TAG_MAX_VALUE: hb_ot_meta_tag_t = 2147483647;
#[doc = " hb_ot_meta_tag_t:\n @HB_OT_META_TAG_DESIGN_LANGUAGES: Design languages. Text, using only\n Basic Latin (ASCII) characters. Indicates languages and/or scripts\n for the user audiences that the font was primarily designed for.\n @HB_OT_META_TAG_SUPPORTED_LANGUAGES: Supported languages. Text, using\n only Basic Latin (ASCII) characters. Indicates languages and/or scripts\n that the font is declared to be capable of supporting.\n\n Known metadata tags from https://docs.microsoft.com/en-us/typography/opentype/spec/meta\n\n Since: 2.6.0"]
pub type hb_ot_meta_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_meta_get_entry_tags(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        entries_count: *mut ::std::os::raw::c_uint,
        entries: *mut hb_ot_meta_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_meta_reference_entry(
        face: *mut hb_face_t,
        meta_tag: hb_ot_meta_tag_t,
    ) -> *mut hb_blob_t;
}
pub const HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER: hb_ot_metrics_tag_t = 1751216995;
pub const HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER: hb_ot_metrics_tag_t = 1751413603;
pub const HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP: hb_ot_metrics_tag_t = 1751934832;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT: hb_ot_metrics_tag_t = 1751346273;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT: hb_ot_metrics_tag_t = 1751346276;
pub const HB_OT_METRICS_TAG_VERTICAL_ASCENDER: hb_ot_metrics_tag_t = 1986098019;
pub const HB_OT_METRICS_TAG_VERTICAL_DESCENDER: hb_ot_metrics_tag_t = 1986294627;
pub const HB_OT_METRICS_TAG_VERTICAL_LINE_GAP: hb_ot_metrics_tag_t = 1986815856;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE: hb_ot_metrics_tag_t = 1751347827;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN: hb_ot_metrics_tag_t = 1751347822;
pub const HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET: hb_ot_metrics_tag_t = 1751347046;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_RISE: hb_ot_metrics_tag_t = 1986228851;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_RUN: hb_ot_metrics_tag_t = 1986228846;
pub const HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET: hb_ot_metrics_tag_t = 1986228070;
pub const HB_OT_METRICS_TAG_X_HEIGHT: hb_ot_metrics_tag_t = 2020108148;
pub const HB_OT_METRICS_TAG_CAP_HEIGHT: hb_ot_metrics_tag_t = 1668311156;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE: hb_ot_metrics_tag_t = 1935833203;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE: hb_ot_metrics_tag_t = 1935833459;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET: hb_ot_metrics_tag_t = 1935833199;
pub const HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET: hb_ot_metrics_tag_t = 1935833455;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE: hb_ot_metrics_tag_t = 1936750707;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE: hb_ot_metrics_tag_t = 1936750963;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET: hb_ot_metrics_tag_t = 1936750703;
pub const HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET: hb_ot_metrics_tag_t = 1936750959;
pub const HB_OT_METRICS_TAG_STRIKEOUT_SIZE: hb_ot_metrics_tag_t = 1937011315;
pub const HB_OT_METRICS_TAG_STRIKEOUT_OFFSET: hb_ot_metrics_tag_t = 1937011311;
pub const HB_OT_METRICS_TAG_UNDERLINE_SIZE: hb_ot_metrics_tag_t = 1970168947;
pub const HB_OT_METRICS_TAG_UNDERLINE_OFFSET: hb_ot_metrics_tag_t = 1970168943;
pub const _HB_OT_METRICS_TAG_MAX_VALUE: hb_ot_metrics_tag_t = 2147483647;
#[doc = " hb_ot_metrics_tag_t:\n @HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER: horizontal ascender.\n @HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER: horizontal descender.\n @HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP: horizontal line gap.\n @HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT: horizontal clipping ascent.\n @HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT: horizontal clipping descent.\n @HB_OT_METRICS_TAG_VERTICAL_ASCENDER: vertical ascender.\n @HB_OT_METRICS_TAG_VERTICAL_DESCENDER: vertical descender.\n @HB_OT_METRICS_TAG_VERTICAL_LINE_GAP: vertical line gap.\n @HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE: horizontal caret rise.\n @HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN: horizontal caret run.\n @HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET: horizontal caret offset.\n @HB_OT_METRICS_TAG_VERTICAL_CARET_RISE: vertical caret rise.\n @HB_OT_METRICS_TAG_VERTICAL_CARET_RUN: vertical caret run.\n @HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET: vertical caret offset.\n @HB_OT_METRICS_TAG_X_HEIGHT: x height.\n @HB_OT_METRICS_TAG_CAP_HEIGHT: cap height.\n @HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE: subscript em x size.\n @HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE: subscript em y size.\n @HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET: subscript em x offset.\n @HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET: subscript em y offset.\n @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE: superscript em x size.\n @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE: superscript em y size.\n @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET: superscript em x offset.\n @HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET: superscript em y offset.\n @HB_OT_METRICS_TAG_STRIKEOUT_SIZE: strikeout size.\n @HB_OT_METRICS_TAG_STRIKEOUT_OFFSET: strikeout offset.\n @HB_OT_METRICS_TAG_UNDERLINE_SIZE: underline size.\n @HB_OT_METRICS_TAG_UNDERLINE_OFFSET: underline offset.\n\n From https://docs.microsoft.com/en-us/typography/opentype/spec/mvar#value-tags\n\n Since: 2.6.0"]
pub type hb_ot_metrics_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_ot_metrics_get_position(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
        position: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_metrics_get_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> ::std::os::raw::c_float;
}
extern "C" {
    pub fn hb_ot_metrics_get_x_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_metrics_get_y_variation(
        font: *mut hb_font_t,
        metrics_tag: hb_ot_metrics_tag_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_shape_glyphs_closure(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_shape_plan_collect_lookups(
        shape_plan: *mut hb_shape_plan_t,
        table_tag: hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_var_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_get_axis_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
pub const HB_OT_VAR_AXIS_FLAG_HIDDEN: hb_ot_var_axis_flags_t = 1;
pub const _HB_OT_VAR_AXIS_FLAG_MAX_VALUE: hb_ot_var_axis_flags_t = 2147483647;
#[doc = " hb_ot_var_axis_flags_t:\n @HB_OT_VAR_AXIS_FLAG_HIDDEN: The axis should not be exposed directly in user interfaces.\n\n Since: 2.2.0"]
pub type hb_ot_var_axis_flags_t = ::std::os::raw::c_uint;
#[doc = " hb_ot_var_axis_info_t:\n @axis_index: Index of the axis in the variation-axis array\n @tag: The #hb_tag_t tag identifying the design variation of the axis\n @name_id: The `name` table Name ID that provides display names for the axis\n @flags: The #hb_ot_var_axis_flags_t flags for the axis\n @min_value: The mininum value on the variation axis that the font covers\n @default_value: The position on the variation axis corresponding to the font's defaults\n @max_value: The maximum value on the variation axis that the font covers\n\n Data type for holding variation-axis values.\n\n The minimum, default, and maximum values are in un-normalized, user scales.\n\n <note>Note: at present, the only flag defined for @flags is\n #HB_OT_VAR_AXIS_FLAG_HIDDEN.</note>\n\n Since: 2.2.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_var_axis_info_t {
    pub axis_index: ::std::os::raw::c_uint,
    pub tag: hb_tag_t,
    pub name_id: hb_ot_name_id_t,
    pub flags: hb_ot_var_axis_flags_t,
    pub min_value: ::std::os::raw::c_float,
    pub default_value: ::std::os::raw::c_float,
    pub max_value: ::std::os::raw::c_float,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_ot_var_axis_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_ot_var_axis_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_ot_var_axis_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_ot_var_axis_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_var_axis_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_var_axis_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axis_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(axis_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(min_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(max_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_info_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn hb_ot_var_get_axis_infos(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        axes_count: *mut ::std::os::raw::c_uint,
        axes_array: *mut hb_ot_var_axis_info_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_find_axis_info(
        face: *mut hb_face_t,
        axis_tag: hb_tag_t,
        axis_info: *mut hb_ot_var_axis_info_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_get_named_instance_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_subfamily_name_id(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_postscript_name_id(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
    ) -> hb_ot_name_id_t;
}
extern "C" {
    pub fn hb_ot_var_named_instance_get_design_coords(
        face: *mut hb_face_t,
        instance_index: ::std::os::raw::c_uint,
        coords_length: *mut ::std::os::raw::c_uint,
        coords: *mut ::std::os::raw::c_float,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_normalize_variations(
        face: *mut hb_face_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
        coords: *mut ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_ot_var_normalize_coords(
        face: *mut hb_face_t,
        coords_length: ::std::os::raw::c_uint,
        design_coords: *const ::std::os::raw::c_float,
        normalized_coords: *mut ::std::os::raw::c_int,
    );
}
pub const HB_AAT_LAYOUT_FEATURE_TYPE_INVALID: hb_aat_layout_feature_type_t = 65535;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC: hb_aat_layout_feature_type_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES: hb_aat_layout_feature_type_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION: hb_aat_layout_feature_type_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE: hb_aat_layout_feature_type_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION: hb_aat_layout_feature_type_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT: hb_aat_layout_feature_type_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING: hb_aat_layout_feature_type_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE: hb_aat_layout_feature_type_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE: hb_aat_layout_feature_type_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION: hb_aat_layout_feature_type_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS: hb_aat_layout_feature_type_t = 11;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE: hb_aat_layout_feature_type_t = 13;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS: hb_aat_layout_feature_type_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS: hb_aat_layout_feature_type_t = 15;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE: hb_aat_layout_feature_type_t = 16;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES: hb_aat_layout_feature_type_t = 17;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE: hb_aat_layout_feature_type_t = 18;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS: hb_aat_layout_feature_type_t = 19;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE: hb_aat_layout_feature_type_t = 20;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE: hb_aat_layout_feature_type_t = 21;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING: hb_aat_layout_feature_type_t = 22;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION: hb_aat_layout_feature_type_t = 23;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE: hb_aat_layout_feature_type_t = 24;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE: hb_aat_layout_feature_type_t = 25;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE: hb_aat_layout_feature_type_t = 26;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE: hb_aat_layout_feature_type_t = 27;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA: hb_aat_layout_feature_type_t = 28;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE: hb_aat_layout_feature_type_t =
    29;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE: hb_aat_layout_feature_type_t =
    30;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE:
    hb_aat_layout_feature_type_t = 31;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN: hb_aat_layout_feature_type_t = 32;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT: hb_aat_layout_feature_type_t = 33;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA: hb_aat_layout_feature_type_t = 34;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES: hb_aat_layout_feature_type_t = 35;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES: hb_aat_layout_feature_type_t = 36;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE: hb_aat_layout_feature_type_t = 37;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE: hb_aat_layout_feature_type_t = 38;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE: hb_aat_layout_feature_type_t = 39;
pub const HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE: hb_aat_layout_feature_type_t = 103;
pub const _HB_AAT_LAYOUT_FEATURE_TYPE_MAX_VALUE: hb_aat_layout_feature_type_t = 2147483647;
#[doc = " hb_aat_layout_feature_type_t:\n @HB_AAT_LAYOUT_FEATURE_TYPE_INVALID: Initial, unset feature type\n @HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC:\n @HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION:\n @HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION:\n @HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT:\n @HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING:\n @HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION:\n @HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS:\n @HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS:\n @HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS:\n @HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES:\n @HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING:\n @HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION:\n @HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT:\n @HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA:\n @HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES:\n @HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE:\n @HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE:\n\n The possible feature types defined for AAT shaping.\n\n Since: 2.2.0"]
pub type hb_aat_layout_feature_type_t = ::std::os::raw::c_uint;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID: hb_aat_layout_feature_selector_t = 65535;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_ON: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_OFF: hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_ON:
    hb_aat_layout_feature_selector_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 15;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_ON: hb_aat_layout_feature_selector_t = 16;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_OFF: hb_aat_layout_feature_selector_t =
    17;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    18;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 19;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    20;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 21;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UNCONNECTED: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PARTIALLY_CONNECTED: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CURSIVE: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_AND_LOWER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_CAPS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_LOWER_CASE: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS_AND_SMALL_CAPS:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_NUMBERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_NUMBERS: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_OFF: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SHOW_DIACRITICS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HIDE_DIACRITICS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DECOMPOSE_DIACRITICS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_OFF: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_OFF: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_ON: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_OFF: hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_ON: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_OFF: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_OFF: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_OFF:
    hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_ON: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_OFF: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ORNAMENTS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DINGBATS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PI_CHARACTERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FLEURONS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DECORATIVE_BORDERS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INTERNATIONAL_SYMBOLS: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MATH_SYMBOLS: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ALTERNATES: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL1: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL2: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL3: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL4: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL5: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DISPLAY_TEXT: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ENGRAVED_TEXT: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ILLUMINATED_CAPS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TALL_CAPS: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_ONE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_TWO: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_THREE: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FOUR: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FIVE: hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS: hb_aat_layout_feature_selector_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS: hb_aat_layout_feature_selector_t = 11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS: hb_aat_layout_feature_selector_t = 12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS: hb_aat_layout_feature_selector_t = 13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS:
    hb_aat_layout_feature_selector_t = 14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HIRAGANA_TO_KATAKANA: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_KATAKANA_TO_HIRAGANA: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_KANA_TO_ROMANIZATION: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_HIRAGANA:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_KATAKANA:
    hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_ONE: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_TWO: hb_aat_layout_feature_selector_t =
    8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_THREE:
    hb_aat_layout_feature_selector_t = 9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ANNOTATION: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_BOX_ANNOTATION: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROUNDED_BOX_ANNOTATION: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CIRCLE_ANNOTATION: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_CIRCLE_ANNOTATION:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PARENTHESIS_ANNOTATION: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIOD_ANNOTATION: hb_aat_layout_feature_selector_t = 6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMAN_NUMERAL_ANNOTATION:
    hb_aat_layout_feature_selector_t = 7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAMOND_ANNOTATION: hb_aat_layout_feature_selector_t = 8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_BOX_ANNOTATION: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_ROUNDED_BOX_ANNOTATION:
    hb_aat_layout_feature_selector_t = 10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_KANA: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_KANA: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_IDEOGRAPHS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_ON:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_RUBY_KANA: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_SYMBOL_ALTERNATIVES:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_ONE: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_TWO: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_THREE: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FOUR: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FIVE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_IDEOGRAPHIC_ALTERNATIVES:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_ONE: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_TWO: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_THREE: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FOUR: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FIVE: hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_CENTERED:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_HBASELINE:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_ITALIC_ROMAN: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN: hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON:
    hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF:
    hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLISTIC_ALTERNATES: hb_aat_layout_feature_selector_t =
    0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF: hb_aat_layout_feature_selector_t =
    3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON: hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF: hb_aat_layout_feature_selector_t =
    5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON: hb_aat_layout_feature_selector_t =
    6;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF: hb_aat_layout_feature_selector_t =
    7;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON: hb_aat_layout_feature_selector_t =
    8;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF: hb_aat_layout_feature_selector_t =
    9;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON: hb_aat_layout_feature_selector_t =
    10;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF: hb_aat_layout_feature_selector_t =
    11;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON: hb_aat_layout_feature_selector_t =
    12;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF: hb_aat_layout_feature_selector_t =
    13;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON: hb_aat_layout_feature_selector_t =
    14;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF: hb_aat_layout_feature_selector_t =
    15;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON: hb_aat_layout_feature_selector_t =
    16;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF: hb_aat_layout_feature_selector_t =
    17;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON: hb_aat_layout_feature_selector_t =
    18;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF: hb_aat_layout_feature_selector_t =
    19;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON: hb_aat_layout_feature_selector_t =
    20;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF: hb_aat_layout_feature_selector_t =
    21;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON: hb_aat_layout_feature_selector_t =
    22;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF:
    hb_aat_layout_feature_selector_t = 23;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON: hb_aat_layout_feature_selector_t =
    24;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF:
    hb_aat_layout_feature_selector_t = 25;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON:
    hb_aat_layout_feature_selector_t = 26;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF:
    hb_aat_layout_feature_selector_t = 27;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON:
    hb_aat_layout_feature_selector_t = 28;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF:
    hb_aat_layout_feature_selector_t = 29;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON:
    hb_aat_layout_feature_selector_t = 30;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF:
    hb_aat_layout_feature_selector_t = 31;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON:
    hb_aat_layout_feature_selector_t = 32;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF:
    hb_aat_layout_feature_selector_t = 33;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON:
    hb_aat_layout_feature_selector_t = 34;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF:
    hb_aat_layout_feature_selector_t = 35;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON:
    hb_aat_layout_feature_selector_t = 36;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF:
    hb_aat_layout_feature_selector_t = 37;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON:
    hb_aat_layout_feature_selector_t = 38;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF:
    hb_aat_layout_feature_selector_t = 39;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON: hb_aat_layout_feature_selector_t =
    40;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF:
    hb_aat_layout_feature_selector_t = 41;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON:
    hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF:
    hb_aat_layout_feature_selector_t = 1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF: hb_aat_layout_feature_selector_t = 3;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON:
    hb_aat_layout_feature_selector_t = 4;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF:
    hb_aat_layout_feature_selector_t = 5;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS: hb_aat_layout_feature_selector_t =
    2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_CJK_ROMAN: hb_aat_layout_feature_selector_t = 0;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_CJK_ROMAN: hb_aat_layout_feature_selector_t =
    1;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_CJK_ROMAN: hb_aat_layout_feature_selector_t = 2;
pub const HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_CJK_ROMAN: hb_aat_layout_feature_selector_t = 3;
pub const _HB_AAT_LAYOUT_FEATURE_SELECTOR_MAX_VALUE: hb_aat_layout_feature_selector_t = 2147483647;
#[doc = " hb_aat_layout_feature_selector_t:\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID: Initial, unset feature selector\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_UNCONNECTED: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PARTIALLY_CONNECTED: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CURSIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_AND_LOWER_CASE: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_CAPS: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_LOWER_CASE: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS_AND_SMALL_CAPS: Deprecated\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SHOW_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HIDE_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DECOMPOSE_DIACRITICS: for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS: for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ORNAMENTS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DINGBATS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PI_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FLEURONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DECORATIVE_BORDERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INTERNATIONAL_SYMBOLS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_MATH_SYMBOLS: for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ALTERNATES: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL1: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL2: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL3: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL4: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL5: for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DISPLAY_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ENGRAVED_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ILLUMINATED_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS: for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT: for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HIRAGANA_TO_KATAKANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_KATAKANA_TO_HIRAGANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_KANA_TO_ROMANIZATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_HIRAGANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_KATAKANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROUNDED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CIRCLE_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_CIRCLE_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PARENTHESIS_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIOD_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMAN_NUMERAL_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAMOND_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_ROUNDED_BOX_ANNOTATION: for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_KANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_KANA: for #HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_IDEOGRAPHS: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_RUBY_KANA: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF instead\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON instead\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_SYMBOL_ALTERNATIVES: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_IDEOGRAPHIC_ALTERNATIVES: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_ONE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_TWO: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_THREE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FOUR: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FIVE: for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_CENTERED: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_HBASELINE: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_ITALIC_ROMAN: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF instead\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN: Deprecated; use #HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON instead\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLISTIC_ALTERNATES: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF: for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS: for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE\n @HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_CJK_ROMAN: for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE\n\n The selectors defined for specifying AAT feature settings.\n\n Since: 2.2.0"]
pub type hb_aat_layout_feature_selector_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_aat_layout_get_feature_types(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        features: *mut hb_aat_layout_feature_type_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_aat_layout_feature_type_get_name_id(
        face: *mut hb_face_t,
        feature_type: hb_aat_layout_feature_type_t,
    ) -> hb_ot_name_id_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_aat_layout_feature_selector_info_t {
    pub name_id: hb_ot_name_id_t,
    pub enable: hb_aat_layout_feature_selector_t,
    pub disable: hb_aat_layout_feature_selector_t,
    pub reserved: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_aat_layout_feature_selector_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_aat_layout_feature_selector_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_aat_layout_feature_selector_info_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hb_aat_layout_feature_selector_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hb_aat_layout_feature_selector_info_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hb_aat_layout_feature_selector_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_aat_layout_feature_selector_info_t),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_aat_layout_feature_selector_info_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_aat_layout_feature_selector_info_t),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_aat_layout_feature_selector_info_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn hb_aat_layout_feature_type_get_selector_infos(
        face: *mut hb_face_t,
        feature_type: hb_aat_layout_feature_type_t,
        start_offset: ::std::os::raw::c_uint,
        selector_count: *mut ::std::os::raw::c_uint,
        selectors: *mut hb_aat_layout_feature_selector_info_t,
        default_index: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_aat_layout_has_substitution(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_aat_layout_has_positioning(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_aat_layout_has_tracking(face: *mut hb_face_t) -> hb_bool_t;
}
#[doc = " @type:\n   FT_Memory\n\n @description:\n   A handle to a given memory manager object, defined with an\n   @FT_MemoryRec structure.\n"]
pub type FT_Memory = *mut FT_MemoryRec_;
#[doc = " @functype:\n   FT_Alloc_Func\n\n @description:\n   A function used to allocate `size` bytes from `memory`.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   size ::\n     The size in bytes to allocate.\n\n @return:\n   Address of new memory block.  0~in case of failure.\n"]
pub type FT_Alloc_Func = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        size: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @functype:\n   FT_Free_Func\n\n @description:\n   A function used to release a given block of memory.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   block ::\n     The address of the target memory block.\n"]
pub type FT_Free_Func = ::std::option::Option<
    unsafe extern "C" fn(memory: FT_Memory, block: *mut ::std::os::raw::c_void),
>;
#[doc = " @functype:\n   FT_Realloc_Func\n\n @description:\n   A function used to re-allocate a given block of memory.\n\n @input:\n   memory ::\n     A handle to the source memory manager.\n\n   cur_size ::\n     The block's current size in bytes.\n\n   new_size ::\n     The block's requested new size.\n\n   block ::\n     The block's current address.\n\n @return:\n   New block address.  0~in case of memory shortage.\n\n @note:\n   In case of error, the old block must still be available.\n"]
pub type FT_Realloc_Func = ::std::option::Option<
    unsafe extern "C" fn(
        memory: FT_Memory,
        cur_size: ::std::os::raw::c_long,
        new_size: ::std::os::raw::c_long,
        block: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @struct:\n   FT_MemoryRec\n\n @description:\n   A structure used to describe a given memory manager to FreeType~2.\n\n @fields:\n   user ::\n     A generic typeless pointer for user data.\n\n   alloc ::\n     A pointer type to an allocation function.\n\n   free ::\n     A pointer type to an memory freeing function.\n\n   realloc ::\n     A pointer type to a reallocation function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_MemoryRec_ {
    pub user: *mut ::std::os::raw::c_void,
    pub alloc: FT_Alloc_Func,
    pub free: FT_Free_Func,
    pub realloc: FT_Realloc_Func,
}
#[test]
fn bindgen_test_layout_FT_MemoryRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_MemoryRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_MemoryRec_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_MemoryRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_MemoryRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_MemoryRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_MemoryRec_),
            "::",
            stringify!(realloc)
        )
    );
}
#[doc = " @type:\n   FT_Stream\n\n @description:\n   A handle to an input stream.\n\n @also:\n   See @FT_StreamRec for the publicly accessible fields of a given stream\n   object.\n"]
pub type FT_Stream = *mut FT_StreamRec_;
#[doc = " @struct:\n   FT_StreamDesc\n\n @description:\n   A union type used to store either a long or a pointer.  This is used\n   to store a file descriptor or a `FILE*` in an input stream.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union FT_StreamDesc_ {
    pub value: ::std::os::raw::c_long,
    pub pointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_StreamDesc_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_StreamDesc_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_StreamDesc_>(),
        8usize,
        concat!("Size of: ", stringify!(FT_StreamDesc_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_StreamDesc_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_StreamDesc_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamDesc_),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamDesc_),
            "::",
            stringify!(pointer)
        )
    );
}
#[doc = " @struct:\n   FT_StreamDesc\n\n @description:\n   A union type used to store either a long or a pointer.  This is used\n   to store a file descriptor or a `FILE*` in an input stream.\n"]
pub type FT_StreamDesc = FT_StreamDesc_;
#[doc = " @functype:\n   FT_Stream_IoFunc\n\n @description:\n   A function used to seek and read data from a given input stream.\n\n @input:\n   stream ::\n     A handle to the source stream.\n\n   offset ::\n     The offset of read in stream (always from start).\n\n   buffer ::\n     The address of the read buffer.\n\n   count ::\n     The number of bytes to read from the stream.\n\n @return:\n   The number of bytes effectively read by the stream.\n\n @note:\n   This function might be called to perform a seek or skip operation with\n   a `count` of~0.  A non-zero return value then indicates an error.\n"]
pub type FT_Stream_IoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        stream: FT_Stream,
        offset: ::std::os::raw::c_ulong,
        buffer: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong,
>;
#[doc = " @functype:\n   FT_Stream_CloseFunc\n\n @description:\n   A function used to close a given input stream.\n\n @input:\n  stream ::\n    A handle to the target stream.\n"]
pub type FT_Stream_CloseFunc = ::std::option::Option<unsafe extern "C" fn(stream: FT_Stream)>;
#[doc = " @struct:\n   FT_StreamRec\n\n @description:\n   A structure used to describe an input stream.\n\n @input:\n   base ::\n     For memory-based streams, this is the address of the first stream\n     byte in memory.  This field should always be set to `NULL` for\n     disk-based streams.\n\n   size ::\n     The stream size in bytes.\n\n     In case of compressed streams where the size is unknown before\n     actually doing the decompression, the value is set to 0x7FFFFFFF.\n     (Note that this size value can occur for normal streams also; it is\n     thus just a hint.)\n\n   pos ::\n     The current position within the stream.\n\n   descriptor ::\n     This field is a union that can hold an integer or a pointer.  It is\n     used by stream implementations to store file descriptors or `FILE*`\n     pointers.\n\n   pathname ::\n     This field is completely ignored by FreeType.  However, it is often\n     useful during debugging to use it to store the stream's filename\n     (where available).\n\n   read ::\n     The stream's input function.\n\n   close ::\n     The stream's close function.\n\n   memory ::\n     The memory manager to use to preload frames.  This is set internally\n     by FreeType and shouldn't be touched by stream implementations.\n\n   cursor ::\n     This field is set and used internally by FreeType when parsing\n     frames.  In particular, the `FT_GET_XXX` macros use this instead of\n     the `pos` field.\n\n   limit ::\n     This field is set and used internally by FreeType when parsing\n     frames.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FT_StreamRec_ {
    pub base: *mut ::std::os::raw::c_uchar,
    pub size: ::std::os::raw::c_ulong,
    pub pos: ::std::os::raw::c_ulong,
    pub descriptor: FT_StreamDesc,
    pub pathname: FT_StreamDesc,
    pub read: FT_Stream_IoFunc,
    pub close: FT_Stream_CloseFunc,
    pub memory: FT_Memory,
    pub cursor: *mut ::std::os::raw::c_uchar,
    pub limit: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_FT_StreamRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_StreamRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_StreamRec_>(),
        80usize,
        concat!("Size of: ", stringify!(FT_StreamRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_StreamRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_StreamRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pathname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(pathname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_StreamRec_),
            "::",
            stringify!(limit)
        )
    );
}
#[doc = " @type:\n   FT_Pos\n\n @description:\n   The type FT_Pos is used to store vectorial coordinates.  Depending on\n   the context, these can represent distances in integer font units, or\n   16.16, or 26.6 fixed-point pixel coordinates."]
pub type FT_Pos = ::std::os::raw::c_long;
#[doc = " @struct:\n   FT_Vector\n\n @description:\n   A simple structure used to store a 2D vector; coordinates are of the\n   FT_Pos type.\n\n @fields:\n   x ::\n     The horizontal coordinate.\n   y ::\n     The vertical coordinate."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Vector_ {
    pub x: FT_Pos,
    pub y: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Vector_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Vector_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Vector_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Vector_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Vector_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Vector_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Vector_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Vector_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " @struct:\n   FT_Vector\n\n @description:\n   A simple structure used to store a 2D vector; coordinates are of the\n   FT_Pos type.\n\n @fields:\n   x ::\n     The horizontal coordinate.\n   y ::\n     The vertical coordinate."]
pub type FT_Vector = FT_Vector_;
#[doc = " @struct:\n   FT_BBox\n\n @description:\n   A structure used to hold an outline's bounding box, i.e., the\n   coordinates of its extrema in the horizontal and vertical directions.\n\n @fields:\n   xMin ::\n     The horizontal minimum (left-most).\n\n   yMin ::\n     The vertical minimum (bottom-most).\n\n   xMax ::\n     The horizontal maximum (right-most).\n\n   yMax ::\n     The vertical maximum (top-most).\n\n @note:\n   The bounding box is specified with the coordinates of the lower left\n   and the upper right corner.  In PostScript, those values are often\n   called (llx,lly) and (urx,ury), respectively.\n\n   If `yMin` is negative, this value gives the glyph's descender.\n   Otherwise, the glyph doesn't descend below the baseline.  Similarly,\n   if `ymax` is positive, this value gives the glyph's ascender.\n\n   `xMin` gives the horizontal distance from the glyph's origin to the\n   left edge of the glyph's bounding box.  If `xMin` is negative, the\n   glyph extends to the left of the origin."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_BBox_ {
    pub xMin: FT_Pos,
    pub yMin: FT_Pos,
    pub xMax: FT_Pos,
    pub yMax: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_BBox_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_BBox_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_BBox_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_BBox_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_BBox_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_BBox_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xMin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(xMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yMin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(yMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xMax) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(xMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yMax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_BBox_),
            "::",
            stringify!(yMax)
        )
    );
}
#[doc = " @struct:\n   FT_BBox\n\n @description:\n   A structure used to hold an outline's bounding box, i.e., the\n   coordinates of its extrema in the horizontal and vertical directions.\n\n @fields:\n   xMin ::\n     The horizontal minimum (left-most).\n\n   yMin ::\n     The vertical minimum (bottom-most).\n\n   xMax ::\n     The horizontal maximum (right-most).\n\n   yMax ::\n     The vertical maximum (top-most).\n\n @note:\n   The bounding box is specified with the coordinates of the lower left\n   and the upper right corner.  In PostScript, those values are often\n   called (llx,lly) and (urx,ury), respectively.\n\n   If `yMin` is negative, this value gives the glyph's descender.\n   Otherwise, the glyph doesn't descend below the baseline.  Similarly,\n   if `ymax` is positive, this value gives the glyph's ascender.\n\n   `xMin` gives the horizontal distance from the glyph's origin to the\n   left edge of the glyph's bounding box.  If `xMin` is negative, the\n   glyph extends to the left of the origin."]
pub type FT_BBox = FT_BBox_;
#[doc = " @struct:\n   FT_Bitmap\n\n @description:\n   A structure used to describe a bitmap or pixmap to the raster.  Note\n   that we now manage pixmaps of various depths through the `pixel_mode`\n   field.\n\n @fields:\n   rows ::\n     The number of bitmap rows.\n\n   width ::\n     The number of pixels in bitmap row.\n\n   pitch ::\n     The pitch's absolute value is the number of bytes taken by one\n     bitmap row, including padding.  However, the pitch is positive when\n     the bitmap has a 'down' flow, and negative when it has an 'up' flow.\n     In all cases, the pitch is an offset to add to a bitmap pointer in\n     order to go down one row.\n\n     Note that 'padding' means the alignment of a bitmap to a byte\n     border, and FreeType functions normally align to the smallest\n     possible integer value.\n\n     For the B/W rasterizer, `pitch` is always an even number.\n\n     To change the pitch of a bitmap (say, to make it a multiple of 4),\n     use @FT_Bitmap_Convert.  Alternatively, you might use callback\n     functions to directly render to the application's surface; see the\n     file `example2.cpp` in the tutorial for a demonstration.\n\n   buffer ::\n     A typeless pointer to the bitmap buffer.  This value should be\n     aligned on 32-bit boundaries in most cases.\n\n   num_grays ::\n     This field is only used with @FT_PIXEL_MODE_GRAY; it gives the\n     number of gray levels used in the bitmap.\n\n   pixel_mode ::\n     The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode\n     for possible values.\n\n   palette_mode ::\n     This field is intended for paletted pixel modes; it indicates how\n     the palette is stored.  Not used currently.\n\n   palette ::\n     A typeless pointer to the bitmap palette; this field is intended for\n     paletted pixel modes.  Not used currently."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_ {
    pub rows: ::std::os::raw::c_uint,
    pub width: ::std::os::raw::c_uint,
    pub pitch: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub num_grays: ::std::os::raw::c_ushort,
    pub pixel_mode: ::std::os::raw::c_uchar,
    pub palette_mode: ::std::os::raw::c_uchar,
    pub palette: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Bitmap_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Bitmap_>(),
        40usize,
        concat!("Size of: ", stringify!(FT_Bitmap_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Bitmap_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Bitmap_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_grays) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(num_grays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_mode) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(pixel_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).palette_mode) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(palette_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).palette) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_),
            "::",
            stringify!(palette)
        )
    );
}
#[doc = " @struct:\n   FT_Bitmap\n\n @description:\n   A structure used to describe a bitmap or pixmap to the raster.  Note\n   that we now manage pixmaps of various depths through the `pixel_mode`\n   field.\n\n @fields:\n   rows ::\n     The number of bitmap rows.\n\n   width ::\n     The number of pixels in bitmap row.\n\n   pitch ::\n     The pitch's absolute value is the number of bytes taken by one\n     bitmap row, including padding.  However, the pitch is positive when\n     the bitmap has a 'down' flow, and negative when it has an 'up' flow.\n     In all cases, the pitch is an offset to add to a bitmap pointer in\n     order to go down one row.\n\n     Note that 'padding' means the alignment of a bitmap to a byte\n     border, and FreeType functions normally align to the smallest\n     possible integer value.\n\n     For the B/W rasterizer, `pitch` is always an even number.\n\n     To change the pitch of a bitmap (say, to make it a multiple of 4),\n     use @FT_Bitmap_Convert.  Alternatively, you might use callback\n     functions to directly render to the application's surface; see the\n     file `example2.cpp` in the tutorial for a demonstration.\n\n   buffer ::\n     A typeless pointer to the bitmap buffer.  This value should be\n     aligned on 32-bit boundaries in most cases.\n\n   num_grays ::\n     This field is only used with @FT_PIXEL_MODE_GRAY; it gives the\n     number of gray levels used in the bitmap.\n\n   pixel_mode ::\n     The pixel mode, i.e., how pixel bits are stored.  See @FT_Pixel_Mode\n     for possible values.\n\n   palette_mode ::\n     This field is intended for paletted pixel modes; it indicates how\n     the palette is stored.  Not used currently.\n\n   palette ::\n     A typeless pointer to the bitmap palette; this field is intended for\n     paletted pixel modes.  Not used currently."]
pub type FT_Bitmap = FT_Bitmap_;
#[doc = " @struct:\n   FT_Outline\n\n @description:\n   This structure is used to describe an outline to the scan-line\n   converter.\n\n @fields:\n   n_contours ::\n     The number of contours in the outline.\n\n   n_points ::\n     The number of points in the outline.\n\n   points ::\n     A pointer to an array of `n_points` @FT_Vector elements, giving the\n     outline's point coordinates.\n\n   tags ::\n     A pointer to an array of `n_points` chars, giving each outline\n     point's type.\n\n     If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier\n     control point, while it is 'on' if set.\n\n     Bit~1 is meaningful for 'off' points only.  If set, it indicates a\n     third-order Bezier arc control point; and a second-order control\n     point if unset.\n\n     If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in\n     the OpenType specification; the value is the same as the argument to\n     the 'SCANMODE' instruction).\n\n     Bits 3 and~4 are reserved for internal purposes.\n\n   contours ::\n     An array of `n_contours` shorts, giving the end point of each\n     contour within the outline.  For example, the first contour is\n     defined by the points '0' to `contours[0]`, the second one is\n     defined by the points `contours[0]+1` to `contours[1]`, etc.\n\n   flags ::\n     A set of bit flags used to characterize the outline and give hints\n     to the scan-converter and hinter on how to convert/grid-fit it.  See\n     @FT_OUTLINE_XXX.\n\n @note:\n   The B/W rasterizer only checks bit~2 in the `tags` array for the first\n   point of each contour.  The drop-out mode as given with\n   @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and\n   @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Outline_ {
    pub n_contours: ::std::os::raw::c_short,
    pub n_points: ::std::os::raw::c_short,
    pub points: *mut FT_Vector,
    pub tags: *mut ::std::os::raw::c_char,
    pub contours: *mut ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FT_Outline_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Outline_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Outline_>(),
        40usize,
        concat!("Size of: ", stringify!(FT_Outline_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Outline_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Outline_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_contours) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(n_contours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_points) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(n_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(tags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contours) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(contours)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Outline_),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " @struct:\n   FT_Outline\n\n @description:\n   This structure is used to describe an outline to the scan-line\n   converter.\n\n @fields:\n   n_contours ::\n     The number of contours in the outline.\n\n   n_points ::\n     The number of points in the outline.\n\n   points ::\n     A pointer to an array of `n_points` @FT_Vector elements, giving the\n     outline's point coordinates.\n\n   tags ::\n     A pointer to an array of `n_points` chars, giving each outline\n     point's type.\n\n     If bit~0 is unset, the point is 'off' the curve, i.e., a Bezier\n     control point, while it is 'on' if set.\n\n     Bit~1 is meaningful for 'off' points only.  If set, it indicates a\n     third-order Bezier arc control point; and a second-order control\n     point if unset.\n\n     If bit~2 is set, bits 5-7 contain the drop-out mode (as defined in\n     the OpenType specification; the value is the same as the argument to\n     the 'SCANMODE' instruction).\n\n     Bits 3 and~4 are reserved for internal purposes.\n\n   contours ::\n     An array of `n_contours` shorts, giving the end point of each\n     contour within the outline.  For example, the first contour is\n     defined by the points '0' to `contours[0]`, the second one is\n     defined by the points `contours[0]+1` to `contours[1]`, etc.\n\n   flags ::\n     A set of bit flags used to characterize the outline and give hints\n     to the scan-converter and hinter on how to convert/grid-fit it.  See\n     @FT_OUTLINE_XXX.\n\n @note:\n   The B/W rasterizer only checks bit~2 in the `tags` array for the first\n   point of each contour.  The drop-out mode as given with\n   @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and\n   @FT_OUTLINE_INCLUDE_STUBS in `flags` is then overridden."]
pub type FT_Outline = FT_Outline_;
pub const FT_GLYPH_FORMAT_NONE: FT_Glyph_Format_ = 0;
pub const FT_GLYPH_FORMAT_COMPOSITE: FT_Glyph_Format_ = 1668246896;
pub const FT_GLYPH_FORMAT_BITMAP: FT_Glyph_Format_ = 1651078259;
pub const FT_GLYPH_FORMAT_OUTLINE: FT_Glyph_Format_ = 1869968492;
pub const FT_GLYPH_FORMAT_PLOTTER: FT_Glyph_Format_ = 1886154612;
#[doc = " @enum:\n   FT_Glyph_Format\n\n @description:\n   An enumeration type used to describe the format of a given glyph\n   image.  Note that this version of FreeType only supports two image\n   formats, even though future font drivers will be able to register\n   their own format.\n\n @values:\n   FT_GLYPH_FORMAT_NONE ::\n     The value~0 is reserved.\n\n   FT_GLYPH_FORMAT_COMPOSITE ::\n     The glyph image is a composite of several other images.  This format\n     is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report\n     compound glyphs (like accented characters).\n\n   FT_GLYPH_FORMAT_BITMAP ::\n     The glyph image is a bitmap, and can be described as an @FT_Bitmap.\n     You generally need to access the `bitmap` field of the\n     @FT_GlyphSlotRec structure to read it.\n\n   FT_GLYPH_FORMAT_OUTLINE ::\n     The glyph image is a vectorial outline made of line segments and\n     Bezier arcs; it can be described as an @FT_Outline; you generally\n     want to access the `outline` field of the @FT_GlyphSlotRec structure\n     to read it.\n\n   FT_GLYPH_FORMAT_PLOTTER ::\n     The glyph image is a vectorial path with no inside and outside\n     contours.  Some Type~1 fonts, like those in the Hershey family,\n     contain glyphs in this format.  These are described as @FT_Outline,\n     but FreeType isn't currently capable of rendering them correctly."]
pub type FT_Glyph_Format_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Glyph_Format\n\n @description:\n   An enumeration type used to describe the format of a given glyph\n   image.  Note that this version of FreeType only supports two image\n   formats, even though future font drivers will be able to register\n   their own format.\n\n @values:\n   FT_GLYPH_FORMAT_NONE ::\n     The value~0 is reserved.\n\n   FT_GLYPH_FORMAT_COMPOSITE ::\n     The glyph image is a composite of several other images.  This format\n     is _only_ used with @FT_LOAD_NO_RECURSE, and is used to report\n     compound glyphs (like accented characters).\n\n   FT_GLYPH_FORMAT_BITMAP ::\n     The glyph image is a bitmap, and can be described as an @FT_Bitmap.\n     You generally need to access the `bitmap` field of the\n     @FT_GlyphSlotRec structure to read it.\n\n   FT_GLYPH_FORMAT_OUTLINE ::\n     The glyph image is a vectorial outline made of line segments and\n     Bezier arcs; it can be described as an @FT_Outline; you generally\n     want to access the `outline` field of the @FT_GlyphSlotRec structure\n     to read it.\n\n   FT_GLYPH_FORMAT_PLOTTER ::\n     The glyph image is a vectorial path with no inside and outside\n     contours.  Some Type~1 fonts, like those in the Hershey family,\n     contain glyphs in this format.  These are described as @FT_Outline,\n     but FreeType isn't currently capable of rendering them correctly."]
pub use self::FT_Glyph_Format_ as FT_Glyph_Format;
#[doc = " @type:\n   FT_String\n\n @description:\n   A simple typedef for the char type, usually used for strings."]
pub type FT_String = ::std::os::raw::c_char;
#[doc = " @type:\n   FT_Short\n\n @description:\n   A typedef for signed short."]
pub type FT_Short = ::std::os::raw::c_short;
#[doc = " @type:\n   FT_UShort\n\n @description:\n   A typedef for unsigned short."]
pub type FT_UShort = ::std::os::raw::c_ushort;
#[doc = " @type:\n   FT_Int\n\n @description:\n   A typedef for the int type."]
pub type FT_Int = ::std::os::raw::c_int;
#[doc = " @type:\n   FT_UInt\n\n @description:\n   A typedef for the unsigned int type."]
pub type FT_UInt = ::std::os::raw::c_uint;
#[doc = " @type:\n   FT_Long\n\n @description:\n   A typedef for signed long."]
pub type FT_Long = ::std::os::raw::c_long;
#[doc = " @type:\n   FT_Fixed\n\n @description:\n   This type is used to store 16.16 fixed-point values, like scaling\n   values or matrix coefficients."]
pub type FT_Fixed = ::std::os::raw::c_long;
#[doc = " @functype:\n   FT_Generic_Finalizer\n\n @description:\n   Describe a function used to destroy the 'client' data of any FreeType\n   object.  See the description of the @FT_Generic type for details of\n   usage.\n\n @input:\n   The address of the FreeType object that is under finalization.  Its\n   client data is accessed through its `generic` field."]
pub type FT_Generic_Finalizer =
    ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>;
#[doc = " @struct:\n   FT_Generic\n\n @description:\n   Client applications often need to associate their own data to a\n   variety of FreeType core objects.  For example, a text layout API\n   might want to associate a glyph cache to a given size object.\n\n   Some FreeType object contains a `generic` field, of type `FT_Generic`,\n   which usage is left to client applications and font servers.\n\n   It can be used to store a pointer to client-specific data, as well as\n   the address of a 'finalizer' function, which will be called by\n   FreeType when the object is destroyed (for example, the previous\n   client example would put the address of the glyph cache destructor in\n   the `finalizer` field).\n\n @fields:\n   data ::\n     A typeless pointer to any client-specified data. This field is\n     completely ignored by the FreeType library.\n\n   finalizer ::\n     A pointer to a 'generic finalizer' function, which will be called\n     when the object is destroyed.  If this field is set to `NULL`, no\n     code will be called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Generic_ {
    pub data: *mut ::std::os::raw::c_void,
    pub finalizer: FT_Generic_Finalizer,
}
#[test]
fn bindgen_test_layout_FT_Generic_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Generic_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Generic_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_Generic_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Generic_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Generic_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Generic_),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalizer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Generic_),
            "::",
            stringify!(finalizer)
        )
    );
}
#[doc = " @struct:\n   FT_Generic\n\n @description:\n   Client applications often need to associate their own data to a\n   variety of FreeType core objects.  For example, a text layout API\n   might want to associate a glyph cache to a given size object.\n\n   Some FreeType object contains a `generic` field, of type `FT_Generic`,\n   which usage is left to client applications and font servers.\n\n   It can be used to store a pointer to client-specific data, as well as\n   the address of a 'finalizer' function, which will be called by\n   FreeType when the object is destroyed (for example, the previous\n   client example would put the address of the glyph cache destructor in\n   the `finalizer` field).\n\n @fields:\n   data ::\n     A typeless pointer to any client-specified data. This field is\n     completely ignored by the FreeType library.\n\n   finalizer ::\n     A pointer to a 'generic finalizer' function, which will be called\n     when the object is destroyed.  If this field is set to `NULL`, no\n     code will be called."]
pub type FT_Generic = FT_Generic_;
#[doc = " @type:\n   FT_ListNode\n\n @description:\n    Many elements and objects in FreeType are listed through an @FT_List\n    record (see @FT_ListRec).  As its name suggests, an FT_ListNode is a\n    handle to a single list element."]
pub type FT_ListNode = *mut FT_ListNodeRec_;
#[doc = " @struct:\n   FT_ListNodeRec\n\n @description:\n   A structure used to hold a single list element.\n\n @fields:\n   prev ::\n     The previous element in the list.  `NULL` if first.\n\n   next ::\n     The next element in the list.  `NULL` if last.\n\n   data ::\n     A typeless pointer to the listed object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListNodeRec_ {
    pub prev: FT_ListNode,
    pub next: FT_ListNode,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FT_ListNodeRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_ListNodeRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_ListNodeRec_>(),
        24usize,
        concat!("Size of: ", stringify!(FT_ListNodeRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_ListNodeRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_ListNodeRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_ListNodeRec_),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " @struct:\n   FT_ListRec\n\n @description:\n   A structure used to hold a simple doubly-linked list.  These are used\n   in many parts of FreeType.\n\n @fields:\n   head ::\n     The head (first element) of doubly-linked list.\n\n   tail ::\n     The tail (last element) of doubly-linked list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_ListRec_ {
    pub head: FT_ListNode,
    pub tail: FT_ListNode,
}
#[test]
fn bindgen_test_layout_FT_ListRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_ListRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_ListRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_ListRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_ListRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_ListRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_ListRec_),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_ListRec_),
            "::",
            stringify!(tail)
        )
    );
}
#[doc = " @struct:\n   FT_ListRec\n\n @description:\n   A structure used to hold a simple doubly-linked list.  These are used\n   in many parts of FreeType.\n\n @fields:\n   head ::\n     The head (first element) of doubly-linked list.\n\n   tail ::\n     The tail (last element) of doubly-linked list."]
pub type FT_ListRec = FT_ListRec_;
#[doc = " @struct:\n   FT_Glyph_Metrics\n\n @description:\n   A structure to model the metrics of a single glyph.  The values are\n   expressed in 26.6 fractional pixel format; if the flag\n   @FT_LOAD_NO_SCALE has been used while loading the glyph, values are\n   expressed in font units instead.\n\n @fields:\n   width ::\n     The glyph's width.\n\n   height ::\n     The glyph's height.\n\n   horiBearingX ::\n     Left side bearing for horizontal layout.\n\n   horiBearingY ::\n     Top side bearing for horizontal layout.\n\n   horiAdvance ::\n     Advance width for horizontal layout.\n\n   vertBearingX ::\n     Left side bearing for vertical layout.\n\n   vertBearingY ::\n     Top side bearing for vertical layout.  Larger positive values mean\n     further below the vertical glyph origin.\n\n   vertAdvance ::\n     Advance height for vertical layout.  Positive values mean the glyph\n     has a positive advance downward.\n\n @note:\n   If not disabled with @FT_LOAD_NO_HINTING, the values represent\n   dimensions of the hinted glyph (in case hinting is applicable).\n\n   Stroking a glyph with an outside border does not increase\n   `horiAdvance` or `vertAdvance`; you have to manually adjust these\n   values to account for the added width and height.\n\n   FreeType doesn't use the 'VORG' table data for CFF fonts because it\n   doesn't have an interface to quickly retrieve the glyph height.  The\n   y~coordinate of the vertical origin can be simply computed as\n   `vertBearingY + height` after loading a glyph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Glyph_Metrics_ {
    pub width: FT_Pos,
    pub height: FT_Pos,
    pub horiBearingX: FT_Pos,
    pub horiBearingY: FT_Pos,
    pub horiAdvance: FT_Pos,
    pub vertBearingX: FT_Pos,
    pub vertBearingY: FT_Pos,
    pub vertAdvance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Glyph_Metrics_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Glyph_Metrics_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Glyph_Metrics_>(),
        64usize,
        concat!("Size of: ", stringify!(FT_Glyph_Metrics_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Glyph_Metrics_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Glyph_Metrics_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horiBearingX) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiBearingX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horiBearingY) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiBearingY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).horiAdvance) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(horiAdvance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertBearingX) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertBearingX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertBearingY) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertBearingY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertAdvance) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Glyph_Metrics_),
            "::",
            stringify!(vertAdvance)
        )
    );
}
#[doc = " @struct:\n   FT_Glyph_Metrics\n\n @description:\n   A structure to model the metrics of a single glyph.  The values are\n   expressed in 26.6 fractional pixel format; if the flag\n   @FT_LOAD_NO_SCALE has been used while loading the glyph, values are\n   expressed in font units instead.\n\n @fields:\n   width ::\n     The glyph's width.\n\n   height ::\n     The glyph's height.\n\n   horiBearingX ::\n     Left side bearing for horizontal layout.\n\n   horiBearingY ::\n     Top side bearing for horizontal layout.\n\n   horiAdvance ::\n     Advance width for horizontal layout.\n\n   vertBearingX ::\n     Left side bearing for vertical layout.\n\n   vertBearingY ::\n     Top side bearing for vertical layout.  Larger positive values mean\n     further below the vertical glyph origin.\n\n   vertAdvance ::\n     Advance height for vertical layout.  Positive values mean the glyph\n     has a positive advance downward.\n\n @note:\n   If not disabled with @FT_LOAD_NO_HINTING, the values represent\n   dimensions of the hinted glyph (in case hinting is applicable).\n\n   Stroking a glyph with an outside border does not increase\n   `horiAdvance` or `vertAdvance`; you have to manually adjust these\n   values to account for the added width and height.\n\n   FreeType doesn't use the 'VORG' table data for CFF fonts because it\n   doesn't have an interface to quickly retrieve the glyph height.  The\n   y~coordinate of the vertical origin can be simply computed as\n   `vertBearingY + height` after loading a glyph."]
pub type FT_Glyph_Metrics = FT_Glyph_Metrics_;
#[doc = " @struct:\n   FT_Bitmap_Size\n\n @description:\n   This structure models the metrics of a bitmap strike (i.e., a set of\n   glyphs for a given point size and resolution) in a bitmap font.  It is\n   used for the `available_sizes` field of @FT_Face.\n\n @fields:\n   height ::\n     The vertical distance, in pixels, between two consecutive baselines.\n     It is always positive.\n\n   width ::\n     The average width, in pixels, of all glyphs in the strike.\n\n   size ::\n     The nominal size of the strike in 26.6 fractional points.  This\n     field is not very useful.\n\n   x_ppem ::\n     The horizontal ppem (nominal width) in 26.6 fractional pixels.\n\n   y_ppem ::\n     The vertical ppem (nominal height) in 26.6 fractional pixels.\n\n @note:\n   Windows FNT:\n     The nominal size given in a FNT font is not reliable.  If the driver\n     finds it incorrect, it sets `size` to some calculated values, and\n     `x_ppem` and `y_ppem` to the pixel width and height given in the\n     font, respectively.\n\n   TrueType embedded bitmaps:\n     `size`, `width`, and `height` values are not contained in the bitmap\n     strike itself.  They are computed from the global font parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Bitmap_Size_ {
    pub height: FT_Short,
    pub width: FT_Short,
    pub size: FT_Pos,
    pub x_ppem: FT_Pos,
    pub y_ppem: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Bitmap_Size_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Bitmap_Size_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Bitmap_Size_>(),
        32usize,
        concat!("Size of: ", stringify!(FT_Bitmap_Size_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Bitmap_Size_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Bitmap_Size_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_ppem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(x_ppem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_ppem) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Bitmap_Size_),
            "::",
            stringify!(y_ppem)
        )
    );
}
#[doc = " @struct:\n   FT_Bitmap_Size\n\n @description:\n   This structure models the metrics of a bitmap strike (i.e., a set of\n   glyphs for a given point size and resolution) in a bitmap font.  It is\n   used for the `available_sizes` field of @FT_Face.\n\n @fields:\n   height ::\n     The vertical distance, in pixels, between two consecutive baselines.\n     It is always positive.\n\n   width ::\n     The average width, in pixels, of all glyphs in the strike.\n\n   size ::\n     The nominal size of the strike in 26.6 fractional points.  This\n     field is not very useful.\n\n   x_ppem ::\n     The horizontal ppem (nominal width) in 26.6 fractional pixels.\n\n   y_ppem ::\n     The vertical ppem (nominal height) in 26.6 fractional pixels.\n\n @note:\n   Windows FNT:\n     The nominal size given in a FNT font is not reliable.  If the driver\n     finds it incorrect, it sets `size` to some calculated values, and\n     `x_ppem` and `y_ppem` to the pixel width and height given in the\n     font, respectively.\n\n   TrueType embedded bitmaps:\n     `size`, `width`, and `height` values are not contained in the bitmap\n     strike itself.  They are computed from the global font parameters."]
pub type FT_Bitmap_Size = FT_Bitmap_Size_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_LibraryRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Library\n\n @description:\n   A handle to a FreeType library instance.  Each 'library' is completely\n   independent from the others; it is the 'root' of a set of objects like\n   fonts, faces, sizes, etc.\n\n   It also embeds a memory manager (see @FT_Memory), as well as a\n   scan-line converter object (see @FT_Raster).\n\n   [Since 2.5.6] In multi-threaded applications it is easiest to use one\n   `FT_Library` object per thread.  In case this is too cumbersome, a\n   single `FT_Library` object across threads is possible also, as long as\n   a mutex lock is used around @FT_New_Face and @FT_Done_Face.\n\n @note:\n   Library objects are normally created by @FT_Init_FreeType, and\n   destroyed with @FT_Done_FreeType.  If you need reference-counting\n   (cf. @FT_Reference_Library), use @FT_New_Library and @FT_Done_Library."]
pub type FT_Library = *mut FT_LibraryRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_DriverRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Driver\n\n @description:\n   A handle to a given FreeType font driver object.  A font driver is a\n   module capable of creating faces from font files."]
pub type FT_Driver = *mut FT_DriverRec_;
#[doc = " @type:\n   FT_Face\n\n @description:\n   A handle to a typographic face object.  A face object models a given\n   typeface, in a given style.\n\n @note:\n   A face object also owns a single @FT_GlyphSlot object, as well as one\n   or more @FT_Size objects.\n\n   Use @FT_New_Face or @FT_Open_Face to create a new face object from a\n   given filepath or a custom input stream.\n\n   Use @FT_Done_Face to destroy it (along with its slot and sizes).\n\n   An `FT_Face` object can only be safely used from one thread at a time.\n   Similarly, creation and destruction of `FT_Face` with the same\n   @FT_Library object can only be done from one thread at a time.  On the\n   other hand, functions like @FT_Load_Glyph and its siblings are\n   thread-safe and do not need the lock to be held as long as the same\n   `FT_Face` object is not used from multiple threads at the same time.\n\n @also:\n   See @FT_FaceRec for the publicly accessible fields of a given face\n   object."]
pub type FT_Face = *mut FT_FaceRec_;
#[doc = " @type:\n   FT_Size\n\n @description:\n   A handle to an object that models a face scaled to a given character\n   size.\n\n @note:\n   An @FT_Face has one _active_ @FT_Size object that is used by functions\n   like @FT_Load_Glyph to determine the scaling transformation that in\n   turn is used to load and hint glyphs and metrics.\n\n   You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes, @FT_Request_Size\n   or even @FT_Select_Size to change the content (i.e., the scaling\n   values) of the active @FT_Size.\n\n   You can use @FT_New_Size to create additional size objects for a given\n   @FT_Face, but they won't be used by other functions until you activate\n   it through @FT_Activate_Size.  Only one size can be activated at any\n   given time per face.\n\n @also:\n   See @FT_SizeRec for the publicly accessible fields of a given size\n   object."]
pub type FT_Size = *mut FT_SizeRec_;
#[doc = " @type:\n   FT_GlyphSlot\n\n @description:\n   A handle to a given 'glyph slot'.  A slot is a container that can hold\n   any of the glyphs contained in its parent face.\n\n   In other words, each time you call @FT_Load_Glyph or @FT_Load_Char,\n   the slot's content is erased by the new glyph data, i.e., the glyph's\n   metrics, its image (bitmap or outline), and other control information.\n\n @also:\n   See @FT_GlyphSlotRec for the publicly accessible glyph fields."]
pub type FT_GlyphSlot = *mut FT_GlyphSlotRec_;
#[doc = " @type:\n   FT_CharMap\n\n @description:\n   A handle to a character map (usually abbreviated to 'charmap').  A\n   charmap is used to translate character codes in a given encoding into\n   glyph indexes for its parent's face.  Some font formats may provide\n   several charmaps per font.\n\n   Each face object owns zero or more charmaps, but only one of them can\n   be 'active', providing the data used by @FT_Get_Char_Index or\n   @FT_Load_Char.\n\n   The list of available charmaps in a face is available through the\n   `face->num_charmaps` and `face->charmaps` fields of @FT_FaceRec.\n\n   The currently active charmap is available as `face->charmap`.  You\n   should call @FT_Set_Charmap to change it.\n\n @note:\n   When a new face is created (either through @FT_New_Face or\n   @FT_Open_Face), the library looks for a Unicode charmap within the\n   list and automatically activates it.  If there is no Unicode charmap,\n   FreeType doesn't set an 'active' charmap.\n\n @also:\n   See @FT_CharMapRec for the publicly accessible fields of a given\n   character map."]
pub type FT_CharMap = *mut FT_CharMapRec_;
pub const FT_ENCODING_NONE: FT_Encoding_ = 0;
pub const FT_ENCODING_MS_SYMBOL: FT_Encoding_ = 1937337698;
pub const FT_ENCODING_UNICODE: FT_Encoding_ = 1970170211;
pub const FT_ENCODING_SJIS: FT_Encoding_ = 1936353651;
pub const FT_ENCODING_PRC: FT_Encoding_ = 1734484000;
pub const FT_ENCODING_BIG5: FT_Encoding_ = 1651074869;
pub const FT_ENCODING_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_ENCODING_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_ENCODING_GB2312: FT_Encoding_ = 1734484000;
pub const FT_ENCODING_MS_SJIS: FT_Encoding_ = 1936353651;
pub const FT_ENCODING_MS_GB2312: FT_Encoding_ = 1734484000;
pub const FT_ENCODING_MS_BIG5: FT_Encoding_ = 1651074869;
pub const FT_ENCODING_MS_WANSUNG: FT_Encoding_ = 2002873971;
pub const FT_ENCODING_MS_JOHAB: FT_Encoding_ = 1785686113;
pub const FT_ENCODING_ADOBE_STANDARD: FT_Encoding_ = 1094995778;
pub const FT_ENCODING_ADOBE_EXPERT: FT_Encoding_ = 1094992453;
pub const FT_ENCODING_ADOBE_CUSTOM: FT_Encoding_ = 1094992451;
pub const FT_ENCODING_ADOBE_LATIN_1: FT_Encoding_ = 1818326065;
pub const FT_ENCODING_OLD_LATIN_2: FT_Encoding_ = 1818326066;
pub const FT_ENCODING_APPLE_ROMAN: FT_Encoding_ = 1634889070;
#[doc = " @enum:\n   FT_Encoding\n\n @description:\n   An enumeration to specify character sets supported by charmaps.  Used\n   in the @FT_Select_Charmap API function.\n\n @note:\n   Despite the name, this enumeration lists specific character\n   repertories (i.e., charsets), and not text encoding methods (e.g.,\n   UTF-8, UTF-16, etc.).\n\n   Other encodings might be defined in the future.\n\n @values:\n   FT_ENCODING_NONE ::\n     The encoding value~0 is reserved for all formats except BDF, PCF,\n     and Windows FNT; see below for more information.\n\n   FT_ENCODING_UNICODE ::\n     The Unicode character set.  This value covers all versions of the\n     Unicode repertoire, including ASCII and Latin-1.  Most fonts include\n     a Unicode charmap, but not all of them.\n\n     For example, if you want to access Unicode value U+1F028 (and the\n     font contains it), use value 0x1F028 as the input value for\n     @FT_Get_Char_Index.\n\n   FT_ENCODING_MS_SYMBOL ::\n     Microsoft Symbol encoding, used to encode mathematical symbols and\n     wingdings.  For more information, see\n     'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',\n     'http://www.kostis.net/charsets/symbol.htm', and\n     'http://www.kostis.net/charsets/wingding.htm'.\n\n     This encoding uses character codes from the PUA (Private Unicode\n     Area) in the range U+F020-U+F0FF.\n\n   FT_ENCODING_SJIS ::\n     Shift JIS encoding for Japanese.  More info at\n     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte\n     encodings below.\n\n   FT_ENCODING_PRC ::\n     Corresponds to encoding systems mainly for Simplified Chinese as\n     used in People's Republic of China (PRC).  The encoding layout is\n     based on GB~2312 and its supersets GBK and GB~18030.\n\n   FT_ENCODING_BIG5 ::\n     Corresponds to an encoding system for Traditional Chinese as used in\n     Taiwan and Hong Kong.\n\n   FT_ENCODING_WANSUNG ::\n     Corresponds to the Korean encoding system known as Extended Wansung\n     (MS Windows code page 949).  For more information see\n     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.\n\n   FT_ENCODING_JOHAB ::\n     The Korean standard character set (KS~C 5601-1992), which\n     corresponds to MS Windows code page 1361.  This character set\n     includes all possible Hangul character combinations.\n\n   FT_ENCODING_ADOBE_LATIN_1 ::\n     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript\n     font.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_STANDARD ::\n     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_EXPERT ::\n     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_CUSTOM ::\n     Corresponds to a custom encoding, as found in Type~1, CFF, and\n     OpenType/CFF fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_APPLE_ROMAN ::\n     Apple roman encoding.  Many TrueType and OpenType fonts contain a\n     charmap for this 8-bit encoding, since older versions of Mac OS are\n     able to use it.\n\n   FT_ENCODING_OLD_LATIN_2 ::\n     This value is deprecated and was neither used nor reported by\n     FreeType.  Don't use or test for it.\n\n   FT_ENCODING_MS_SJIS ::\n     Same as FT_ENCODING_SJIS.  Deprecated.\n\n   FT_ENCODING_MS_GB2312 ::\n     Same as FT_ENCODING_PRC.  Deprecated.\n\n   FT_ENCODING_MS_BIG5 ::\n     Same as FT_ENCODING_BIG5.  Deprecated.\n\n   FT_ENCODING_MS_WANSUNG ::\n     Same as FT_ENCODING_WANSUNG.  Deprecated.\n\n   FT_ENCODING_MS_JOHAB ::\n     Same as FT_ENCODING_JOHAB.  Deprecated.\n\n @note:\n   By default, FreeType enables a Unicode charmap and tags it with\n   `FT_ENCODING_UNICODE` when it is either provided or can be generated\n   from PostScript glyph name dictionaries in the font file.  All other\n   encodings are considered legacy and tagged only if explicitly defined\n   in the font file.  Otherwise, `FT_ENCODING_NONE` is used.\n\n   `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is\n   neither Unicode nor ISO-8859-1 (otherwise it is set to\n   `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which\n   encoding is really present.  If, for example, the `cs_registry` field\n   is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in\n   KOI8-R.\n\n   `FT_ENCODING_NONE` is always set (with a single exception) by the\n   winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`\n   field of the @FT_WinFNT_HeaderRec structure to find out which encoding\n   is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means\n   Windows code page 1251 (for Russian).\n\n   `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH\n   and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to\n   `FT_ENCODING_APPLE_ROMAN`).\n\n   If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function\n   @FT_Get_CMap_Language_ID to query the Mac language ID that may be\n   needed to be able to distinguish Apple encoding variants.  See\n\n     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\n   to get an idea how to do that.  Basically, if the language ID is~0,\n   don't use it, otherwise subtract 1 from the language ID.  Then examine\n   `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`\n   and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the\n   Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with\n   `TT_MAC_LANGID_FARSI` means the Farsi variant the Arabic encoding."]
pub type FT_Encoding_ = ::std::os::raw::c_uint;
#[doc = " @enum:\n   FT_Encoding\n\n @description:\n   An enumeration to specify character sets supported by charmaps.  Used\n   in the @FT_Select_Charmap API function.\n\n @note:\n   Despite the name, this enumeration lists specific character\n   repertories (i.e., charsets), and not text encoding methods (e.g.,\n   UTF-8, UTF-16, etc.).\n\n   Other encodings might be defined in the future.\n\n @values:\n   FT_ENCODING_NONE ::\n     The encoding value~0 is reserved for all formats except BDF, PCF,\n     and Windows FNT; see below for more information.\n\n   FT_ENCODING_UNICODE ::\n     The Unicode character set.  This value covers all versions of the\n     Unicode repertoire, including ASCII and Latin-1.  Most fonts include\n     a Unicode charmap, but not all of them.\n\n     For example, if you want to access Unicode value U+1F028 (and the\n     font contains it), use value 0x1F028 as the input value for\n     @FT_Get_Char_Index.\n\n   FT_ENCODING_MS_SYMBOL ::\n     Microsoft Symbol encoding, used to encode mathematical symbols and\n     wingdings.  For more information, see\n     'https://www.microsoft.com/typography/otspec/recom.htm#non-standard-symbol-fonts',\n     'http://www.kostis.net/charsets/symbol.htm', and\n     'http://www.kostis.net/charsets/wingding.htm'.\n\n     This encoding uses character codes from the PUA (Private Unicode\n     Area) in the range U+F020-U+F0FF.\n\n   FT_ENCODING_SJIS ::\n     Shift JIS encoding for Japanese.  More info at\n     'https://en.wikipedia.org/wiki/Shift_JIS'.  See note on multi-byte\n     encodings below.\n\n   FT_ENCODING_PRC ::\n     Corresponds to encoding systems mainly for Simplified Chinese as\n     used in People's Republic of China (PRC).  The encoding layout is\n     based on GB~2312 and its supersets GBK and GB~18030.\n\n   FT_ENCODING_BIG5 ::\n     Corresponds to an encoding system for Traditional Chinese as used in\n     Taiwan and Hong Kong.\n\n   FT_ENCODING_WANSUNG ::\n     Corresponds to the Korean encoding system known as Extended Wansung\n     (MS Windows code page 949).  For more information see\n     'https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WindowsBestFit/bestfit949.txt'.\n\n   FT_ENCODING_JOHAB ::\n     The Korean standard character set (KS~C 5601-1992), which\n     corresponds to MS Windows code page 1361.  This character set\n     includes all possible Hangul character combinations.\n\n   FT_ENCODING_ADOBE_LATIN_1 ::\n     Corresponds to a Latin-1 encoding as defined in a Type~1 PostScript\n     font.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_STANDARD ::\n     Adobe Standard encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_EXPERT ::\n     Adobe Expert encoding, as found in Type~1, CFF, and OpenType/CFF\n     fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_ADOBE_CUSTOM ::\n     Corresponds to a custom encoding, as found in Type~1, CFF, and\n     OpenType/CFF fonts.  It is limited to 256 character codes.\n\n   FT_ENCODING_APPLE_ROMAN ::\n     Apple roman encoding.  Many TrueType and OpenType fonts contain a\n     charmap for this 8-bit encoding, since older versions of Mac OS are\n     able to use it.\n\n   FT_ENCODING_OLD_LATIN_2 ::\n     This value is deprecated and was neither used nor reported by\n     FreeType.  Don't use or test for it.\n\n   FT_ENCODING_MS_SJIS ::\n     Same as FT_ENCODING_SJIS.  Deprecated.\n\n   FT_ENCODING_MS_GB2312 ::\n     Same as FT_ENCODING_PRC.  Deprecated.\n\n   FT_ENCODING_MS_BIG5 ::\n     Same as FT_ENCODING_BIG5.  Deprecated.\n\n   FT_ENCODING_MS_WANSUNG ::\n     Same as FT_ENCODING_WANSUNG.  Deprecated.\n\n   FT_ENCODING_MS_JOHAB ::\n     Same as FT_ENCODING_JOHAB.  Deprecated.\n\n @note:\n   By default, FreeType enables a Unicode charmap and tags it with\n   `FT_ENCODING_UNICODE` when it is either provided or can be generated\n   from PostScript glyph name dictionaries in the font file.  All other\n   encodings are considered legacy and tagged only if explicitly defined\n   in the font file.  Otherwise, `FT_ENCODING_NONE` is used.\n\n   `FT_ENCODING_NONE` is set by the BDF and PCF drivers if the charmap is\n   neither Unicode nor ISO-8859-1 (otherwise it is set to\n   `FT_ENCODING_UNICODE`).  Use @FT_Get_BDF_Charset_ID to find out which\n   encoding is really present.  If, for example, the `cs_registry` field\n   is 'KOI8' and the `cs_encoding` field is 'R', the font is encoded in\n   KOI8-R.\n\n   `FT_ENCODING_NONE` is always set (with a single exception) by the\n   winfonts driver.  Use @FT_Get_WinFNT_Header and examine the `charset`\n   field of the @FT_WinFNT_HeaderRec structure to find out which encoding\n   is really present.  For example, @FT_WinFNT_ID_CP1251 (204) means\n   Windows code page 1251 (for Russian).\n\n   `FT_ENCODING_NONE` is set if `platform_id` is @TT_PLATFORM_MACINTOSH\n   and `encoding_id` is not `TT_MAC_ID_ROMAN` (otherwise it is set to\n   `FT_ENCODING_APPLE_ROMAN`).\n\n   If `platform_id` is @TT_PLATFORM_MACINTOSH, use the function\n   @FT_Get_CMap_Language_ID to query the Mac language ID that may be\n   needed to be able to distinguish Apple encoding variants.  See\n\n     https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\n\n   to get an idea how to do that.  Basically, if the language ID is~0,\n   don't use it, otherwise subtract 1 from the language ID.  Then examine\n   `encoding_id`.  If, for example, `encoding_id` is `TT_MAC_ID_ROMAN`\n   and the language ID (minus~1) is `TT_MAC_LANGID_GREEK`, it is the\n   Greek encoding, not Roman.  `TT_MAC_ID_ARABIC` with\n   `TT_MAC_LANGID_FARSI` means the Farsi variant the Arabic encoding."]
pub use self::FT_Encoding_ as FT_Encoding;
#[doc = " @struct:\n   FT_CharMapRec\n\n @description:\n   The base charmap structure.\n\n @fields:\n   face ::\n     A handle to the parent face object.\n\n   encoding ::\n     An @FT_Encoding tag identifying the charmap.  Use this with\n     @FT_Select_Charmap.\n\n   platform_id ::\n     An ID number describing the platform for the following encoding ID.\n     This comes directly from the TrueType specification and gets\n     emulated for other formats.\n\n   encoding_id ::\n     A platform-specific encoding number.  This also comes from the\n     TrueType specification and gets emulated similarly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_CharMapRec_ {
    pub face: FT_Face,
    pub encoding: FT_Encoding,
    pub platform_id: FT_UShort,
    pub encoding_id: FT_UShort,
}
#[test]
fn bindgen_test_layout_FT_CharMapRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_CharMapRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_CharMapRec_>(),
        16usize,
        concat!("Size of: ", stringify!(FT_CharMapRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_CharMapRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_CharMapRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).platform_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(platform_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding_id) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_CharMapRec_),
            "::",
            stringify!(encoding_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Face_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Face_Internal\n\n @description:\n   An opaque handle to an `FT_Face_InternalRec` structure that models the\n   private data of a given @FT_Face object.\n\n   This structure might change between releases of FreeType~2 and is not\n   generally available to client applications."]
pub type FT_Face_Internal = *mut FT_Face_InternalRec_;
#[doc = " @struct:\n   FT_FaceRec\n\n @description:\n   FreeType root face class structure.  A face object models a typeface\n   in a font file.\n\n @fields:\n   num_faces ::\n     The number of faces in the font file.  Some font formats can have\n     multiple faces in a single font file.\n\n   face_index ::\n     This field holds two different values.  Bits 0-15 are the index of\n     the face in the font file (starting with value~0).  They are set\n     to~0 if there is only one face in the font file.\n\n     [Since 2.6.1] Bits 16-30 are relevant to GX and OpenType variation\n     fonts only, holding the named instance index for the current face\n     index (starting with value~1; value~0 indicates font access without\n     a named instance).  For non-variation fonts, bits 16-30 are ignored.\n     If we have the third named instance of face~4, say, `face_index` is\n     set to 0x00030004.\n\n     Bit 31 is always zero (this is, `face_index` is always a positive\n     value).\n\n     [Since 2.9] Changing the design coordinates with\n     @FT_Set_Var_Design_Coordinates or @FT_Set_Var_Blend_Coordinates does\n     not influence the named instance index value (only\n     @FT_Set_Named_Instance does that).\n\n   face_flags ::\n     A set of bit flags that give important information about the face;\n     see @FT_FACE_FLAG_XXX for the details.\n\n   style_flags ::\n     The lower 16~bits contain a set of bit flags indicating the style of\n     the face; see @FT_STYLE_FLAG_XXX for the details.\n\n     [Since 2.6.1] Bits 16-30 hold the number of named instances\n     available for the current face if we have a GX or OpenType variation\n     (sub)font.  Bit 31 is always zero (this is, `style_flags` is always\n     a positive value).  Note that a variation font has always at least\n     one named instance, namely the default instance.\n\n   num_glyphs ::\n     The number of glyphs in the face.  If the face is scalable and has\n     sbits (see `num_fixed_sizes`), it is set to the number of outline\n     glyphs.\n\n     For CID-keyed fonts (not in an SFNT wrapper) this value gives the\n     highest CID used in the font.\n\n   family_name ::\n     The face's family name.  This is an ASCII string, usually in\n     English, that describes the typeface's family (like 'Times New\n     Roman', 'Bodoni', 'Garamond', etc).  This is a least common\n     denominator used to list fonts.  Some formats (TrueType & OpenType)\n     provide localized and Unicode versions of this string.  Applications\n     should use the format-specific interface to access them.  Can be\n     `NULL` (e.g., in fonts embedded in a PDF file).\n\n     In case the font doesn't provide a specific family name entry,\n     FreeType tries to synthesize one, deriving it from other name\n     entries.\n\n   style_name ::\n     The face's style name.  This is an ASCII string, usually in English,\n     that describes the typeface's style (like 'Italic', 'Bold',\n     'Condensed', etc).  Not all font formats provide a style name, so\n     this field is optional, and can be set to `NULL`.  As for\n     `family_name`, some formats provide localized and Unicode versions\n     of this string.  Applications should use the format-specific\n     interface to access them.\n\n   num_fixed_sizes ::\n     The number of bitmap strikes in the face.  Even if the face is\n     scalable, there might still be bitmap strikes, which are called\n     'sbits' in that case.\n\n   available_sizes ::\n     An array of @FT_Bitmap_Size for all bitmap strikes in the face.  It\n     is set to `NULL` if there is no bitmap strike.\n\n     Note that FreeType tries to sanitize the strike data since they are\n     sometimes sloppy or incorrect, but this can easily fail.\n\n   num_charmaps ::\n     The number of charmaps in the face.\n\n   charmaps ::\n     An array of the charmaps of the face.\n\n   generic ::\n     A field reserved for client uses.  See the @FT_Generic type\n     description.\n\n   bbox ::\n     The font bounding box.  Coordinates are expressed in font units (see\n     `units_per_EM`).  The box is large enough to contain any glyph from\n     the font.  Thus, `bbox.yMax` can be seen as the 'maximum ascender',\n     and `bbox.yMin` as the 'minimum descender'.  Only relevant for\n     scalable formats.\n\n     Note that the bounding box might be off by (at least) one pixel for\n     hinted fonts.  See @FT_Size_Metrics for further discussion.\n\n   units_per_EM ::\n     The number of font units per EM square for this face.  This is\n     typically 2048 for TrueType fonts, and 1000 for Type~1 fonts.  Only\n     relevant for scalable formats.\n\n   ascender ::\n     The typographic ascender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMax`.\n     Only relevant for scalable formats.\n\n   descender ::\n     The typographic descender of the face, expressed in font units.  For\n     font formats not having this information, it is set to `bbox.yMin`.\n     Note that this field is negative for values below the baseline.\n     Only relevant for scalable formats.\n\n   height ::\n     This value is the vertical distance between two consecutive\n     baselines, expressed in font units.  It is always positive.  Only\n     relevant for scalable formats.\n\n     If you want the global glyph height, use `ascender - descender`.\n\n   max_advance_width ::\n     The maximum advance width, in font units, for all glyphs in this\n     face.  This can be used to make word wrapping computations faster.\n     Only relevant for scalable formats.\n\n   max_advance_height ::\n     The maximum advance height, in font units, for all glyphs in this\n     face.  This is only relevant for vertical layouts, and is set to\n     `height` for fonts that do not provide vertical metrics.  Only\n     relevant for scalable formats.\n\n   underline_position ::\n     The position, in font units, of the underline line for this face.\n     It is the center of the underlining stem.  Only relevant for\n     scalable formats.\n\n   underline_thickness ::\n     The thickness, in font units, of the underline for this face.  Only\n     relevant for scalable formats.\n\n   glyph ::\n     The face's associated glyph slot(s).\n\n   size ::\n     The current active size for this face.\n\n   charmap ::\n     The current active charmap for this face.\n\n @note:\n   Fields may be changed after a call to @FT_Attach_File or\n   @FT_Attach_Stream.\n\n   For an OpenType variation font, the values of the following fields can\n   change after a call to @FT_Set_Var_Design_Coordinates (and friends) if\n   the font contains an 'MVAR' table: `ascender`, `descender`, `height`,\n   `underline_position`, and `underline_thickness`.\n\n   Especially for TrueType fonts see also the documentation for\n   @FT_Size_Metrics."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_FaceRec_ {
    pub num_faces: FT_Long,
    pub face_index: FT_Long,
    pub face_flags: FT_Long,
    pub style_flags: FT_Long,
    pub num_glyphs: FT_Long,
    pub family_name: *mut FT_String,
    pub style_name: *mut FT_String,
    pub num_fixed_sizes: FT_Int,
    pub available_sizes: *mut FT_Bitmap_Size,
    pub num_charmaps: FT_Int,
    pub charmaps: *mut FT_CharMap,
    pub generic: FT_Generic,
    pub bbox: FT_BBox,
    pub units_per_EM: FT_UShort,
    pub ascender: FT_Short,
    pub descender: FT_Short,
    pub height: FT_Short,
    pub max_advance_width: FT_Short,
    pub max_advance_height: FT_Short,
    pub underline_position: FT_Short,
    pub underline_thickness: FT_Short,
    pub glyph: FT_GlyphSlot,
    pub size: FT_Size,
    pub charmap: FT_CharMap,
    pub driver: FT_Driver,
    pub memory: FT_Memory,
    pub stream: FT_Stream,
    pub sizes_list: FT_ListRec,
    pub autohint: FT_Generic,
    pub extensions: *mut ::std::os::raw::c_void,
    pub internal: FT_Face_Internal,
}
#[test]
fn bindgen_test_layout_FT_FaceRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_FaceRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_FaceRec_>(),
        248usize,
        concat!("Size of: ", stringify!(FT_FaceRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_FaceRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_FaceRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_faces) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_faces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face_index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(face_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(face_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).style_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(style_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_glyphs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_glyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).family_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(family_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).style_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(style_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_fixed_sizes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_fixed_sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).available_sizes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(available_sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_charmaps) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(num_charmaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charmaps) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(charmaps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units_per_EM) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(units_per_EM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascender) as usize - ptr as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_advance_width) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(max_advance_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_advance_height) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(max_advance_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).underline_position) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(underline_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).underline_thickness) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(underline_thickness)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charmap) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(charmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizes_list) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(sizes_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autohint) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(autohint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extensions) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_FaceRec_),
            "::",
            stringify!(internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Size_Internal\n\n @description:\n   An opaque handle to an `FT_Size_InternalRec` structure, used to model\n   private data of a given @FT_Size object."]
pub type FT_Size_Internal = *mut FT_Size_InternalRec_;
#[doc = " @struct:\n   FT_Size_Metrics\n\n @description:\n   The size metrics structure gives the metrics of a size object.\n\n @fields:\n   x_ppem ::\n     The width of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal width'.\n\n   y_ppem ::\n     The height of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal height'.\n\n   x_scale ::\n     A 16.16 fractional scaling value to convert horizontal metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   y_scale ::\n     A 16.16 fractional scaling value to convert vertical metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   ascender ::\n     The ascender in 26.6 fractional pixels, rounded up to an integer\n     value.  See @FT_FaceRec for the details.\n\n   descender ::\n     The descender in 26.6 fractional pixels, rounded down to an integer\n     value.  See @FT_FaceRec for the details.\n\n   height ::\n     The height in 26.6 fractional pixels, rounded to an integer value.\n     See @FT_FaceRec for the details.\n\n   max_advance ::\n     The maximum advance width in 26.6 fractional pixels, rounded to an\n     integer value.  See @FT_FaceRec for the details.\n\n @note:\n   The scaling values, if relevant, are determined first during a size\n   changing operation.  The remaining fields are then set by the driver.\n   For scalable formats, they are usually set to scaled values of the\n   corresponding fields in @FT_FaceRec.  Some values like ascender or\n   descender are rounded for historical reasons; more precise values (for\n   outline fonts) can be derived by scaling the corresponding @FT_FaceRec\n   values manually, with code similar to the following.\n\n   ```\n     scaled_ascender = FT_MulFix( face->ascender,\n                                  size_metrics->y_scale );\n   ```\n\n   Note that due to glyph hinting and the selected rendering mode these\n   values are usually not exact; consequently, they must be treated as\n   unreliable with an error margin of at least one pixel!\n\n   Indeed, the only way to get the exact metrics is to render _all_\n   glyphs.  As this would be a definite performance hit, it is up to\n   client applications to perform such computations.\n\n   The `FT_Size_Metrics` structure is valid for bitmap fonts also.\n\n\n   **TrueType fonts with native bytecode hinting**\n\n   All applications that handle TrueType fonts with native hinting must\n   be aware that TTFs expect different rounding of vertical font\n   dimensions.  The application has to cater for this, especially if it\n   wants to rely on a TTF's vertical data (for example, to properly align\n   box characters vertically).\n\n   Only the application knows _in advance_ that it is going to use native\n   hinting for TTFs!  FreeType, on the other hand, selects the hinting\n   mode not at the time of creating an @FT_Size object but much later,\n   namely while calling @FT_Load_Glyph.\n\n   Here is some pseudo code that illustrates a possible solution.\n\n   ```\n     font_format = FT_Get_Font_Format( face );\n\n     if ( !strcmp( font_format, \"TrueType\" ) &&\n          do_native_bytecode_hinting         )\n     {\n       ascender  = ROUND( FT_MulFix( face->ascender,\n                                     size_metrics->y_scale ) );\n       descender = ROUND( FT_MulFix( face->descender,\n                                     size_metrics->y_scale ) );\n     }\n     else\n     {\n       ascender  = size_metrics->ascender;\n       descender = size_metrics->descender;\n     }\n\n     height      = size_metrics->height;\n     max_advance = size_metrics->max_advance;\n   ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Size_Metrics_ {
    pub x_ppem: FT_UShort,
    pub y_ppem: FT_UShort,
    pub x_scale: FT_Fixed,
    pub y_scale: FT_Fixed,
    pub ascender: FT_Pos,
    pub descender: FT_Pos,
    pub height: FT_Pos,
    pub max_advance: FT_Pos,
}
#[test]
fn bindgen_test_layout_FT_Size_Metrics_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_Size_Metrics_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_Size_Metrics_>(),
        56usize,
        concat!("Size of: ", stringify!(FT_Size_Metrics_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_Size_Metrics_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_Size_Metrics_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_ppem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(x_ppem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_ppem) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(y_ppem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(x_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(y_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascender) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_advance) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_Size_Metrics_),
            "::",
            stringify!(max_advance)
        )
    );
}
#[doc = " @struct:\n   FT_Size_Metrics\n\n @description:\n   The size metrics structure gives the metrics of a size object.\n\n @fields:\n   x_ppem ::\n     The width of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal width'.\n\n   y_ppem ::\n     The height of the scaled EM square in pixels, hence the term 'ppem'\n     (pixels per EM).  It is also referred to as 'nominal height'.\n\n   x_scale ::\n     A 16.16 fractional scaling value to convert horizontal metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   y_scale ::\n     A 16.16 fractional scaling value to convert vertical metrics from\n     font units to 26.6 fractional pixels.  Only relevant for scalable\n     font formats.\n\n   ascender ::\n     The ascender in 26.6 fractional pixels, rounded up to an integer\n     value.  See @FT_FaceRec for the details.\n\n   descender ::\n     The descender in 26.6 fractional pixels, rounded down to an integer\n     value.  See @FT_FaceRec for the details.\n\n   height ::\n     The height in 26.6 fractional pixels, rounded to an integer value.\n     See @FT_FaceRec for the details.\n\n   max_advance ::\n     The maximum advance width in 26.6 fractional pixels, rounded to an\n     integer value.  See @FT_FaceRec for the details.\n\n @note:\n   The scaling values, if relevant, are determined first during a size\n   changing operation.  The remaining fields are then set by the driver.\n   For scalable formats, they are usually set to scaled values of the\n   corresponding fields in @FT_FaceRec.  Some values like ascender or\n   descender are rounded for historical reasons; more precise values (for\n   outline fonts) can be derived by scaling the corresponding @FT_FaceRec\n   values manually, with code similar to the following.\n\n   ```\n     scaled_ascender = FT_MulFix( face->ascender,\n                                  size_metrics->y_scale );\n   ```\n\n   Note that due to glyph hinting and the selected rendering mode these\n   values are usually not exact; consequently, they must be treated as\n   unreliable with an error margin of at least one pixel!\n\n   Indeed, the only way to get the exact metrics is to render _all_\n   glyphs.  As this would be a definite performance hit, it is up to\n   client applications to perform such computations.\n\n   The `FT_Size_Metrics` structure is valid for bitmap fonts also.\n\n\n   **TrueType fonts with native bytecode hinting**\n\n   All applications that handle TrueType fonts with native hinting must\n   be aware that TTFs expect different rounding of vertical font\n   dimensions.  The application has to cater for this, especially if it\n   wants to rely on a TTF's vertical data (for example, to properly align\n   box characters vertically).\n\n   Only the application knows _in advance_ that it is going to use native\n   hinting for TTFs!  FreeType, on the other hand, selects the hinting\n   mode not at the time of creating an @FT_Size object but much later,\n   namely while calling @FT_Load_Glyph.\n\n   Here is some pseudo code that illustrates a possible solution.\n\n   ```\n     font_format = FT_Get_Font_Format( face );\n\n     if ( !strcmp( font_format, \"TrueType\" ) &&\n          do_native_bytecode_hinting         )\n     {\n       ascender  = ROUND( FT_MulFix( face->ascender,\n                                     size_metrics->y_scale ) );\n       descender = ROUND( FT_MulFix( face->descender,\n                                     size_metrics->y_scale ) );\n     }\n     else\n     {\n       ascender  = size_metrics->ascender;\n       descender = size_metrics->descender;\n     }\n\n     height      = size_metrics->height;\n     max_advance = size_metrics->max_advance;\n   ```"]
pub type FT_Size_Metrics = FT_Size_Metrics_;
#[doc = " @struct:\n   FT_SizeRec\n\n @description:\n   FreeType root size class structure.  A size object models a face\n   object at a given size.\n\n @fields:\n   face ::\n     Handle to the parent face object.\n\n   generic ::\n     A typeless pointer, unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each size object.\n\n   metrics ::\n     Metrics for this size object.  This field is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SizeRec_ {
    pub face: FT_Face,
    pub generic: FT_Generic,
    pub metrics: FT_Size_Metrics,
    pub internal: FT_Size_Internal,
}
#[test]
fn bindgen_test_layout_FT_SizeRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_SizeRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_SizeRec_>(),
        88usize,
        concat!("Size of: ", stringify!(FT_SizeRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_SizeRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_SizeRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metrics) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_SizeRec_),
            "::",
            stringify!(internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_SubGlyphRec_ {
    _unused: [u8; 0],
}
#[doc = " @struct:\n   FT_SubGlyph\n\n @description:\n   The subglyph structure is an internal object used to describe\n   subglyphs (for example, in the case of composites).\n\n @note:\n   The subglyph implementation is not part of the high-level API, hence\n   the forward structure declaration.\n\n   You can however retrieve subglyph information with\n   @FT_Get_SubGlyph_Info."]
pub type FT_SubGlyph = *mut FT_SubGlyphRec_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_Slot_InternalRec_ {
    _unused: [u8; 0],
}
#[doc = " @type:\n   FT_Slot_Internal\n\n @description:\n   An opaque handle to an `FT_Slot_InternalRec` structure, used to model\n   private data of a given @FT_GlyphSlot object."]
pub type FT_Slot_Internal = *mut FT_Slot_InternalRec_;
#[doc = " @struct:\n   FT_GlyphSlotRec\n\n @description:\n   FreeType root glyph slot class structure.  A glyph slot is a container\n   where individual glyphs can be loaded, be they in outline or bitmap\n   format.\n\n @fields:\n   library ::\n     A handle to the FreeType library instance this slot belongs to.\n\n   face ::\n     A handle to the parent face object.\n\n   next ::\n     In some cases (like some font tools), several glyph slots per face\n     object can be a good thing.  As this is rare, the glyph slots are\n     listed through a direct, single-linked list using its `next` field.\n\n   glyph_index ::\n     [Since 2.10] The glyph index passed as an argument to @FT_Load_Glyph\n     while initializing the glyph slot.\n\n   generic ::\n     A typeless pointer unused by the FreeType library or any of its\n     drivers.  It can be used by client applications to link their own\n     data to each glyph slot object.\n\n   metrics ::\n     The metrics of the last loaded glyph in the slot.  The returned\n     values depend on the last load flags (see the @FT_Load_Glyph API\n     function) and can be expressed either in 26.6 fractional pixels or\n     font units.\n\n     Note that even when the glyph image is transformed, the metrics are\n     not.\n\n   linearHoriAdvance ::\n     The advance width of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for outline glyphs.\n\n   linearVertAdvance ::\n     The advance height of the unhinted glyph.  Its value is expressed in\n     16.16 fractional pixels, unless @FT_LOAD_LINEAR_DESIGN is set when\n     loading the glyph.  This field can be important to perform correct\n     WYSIWYG layout.  Only relevant for outline glyphs.\n\n   advance ::\n     This shorthand is, depending on @FT_LOAD_IGNORE_TRANSFORM, the\n     transformed (hinted) advance width for the glyph, in 26.6 fractional\n     pixel format.  As specified with @FT_LOAD_VERTICAL_LAYOUT, it uses\n     either the `horiAdvance` or the `vertAdvance` value of `metrics`\n     field.\n\n   format ::\n     This field indicates the format of the image contained in the glyph\n     slot.  Typically @FT_GLYPH_FORMAT_BITMAP, @FT_GLYPH_FORMAT_OUTLINE,\n     or @FT_GLYPH_FORMAT_COMPOSITE, but other values are possible.\n\n   bitmap ::\n     This field is used as a bitmap descriptor.  Note that the address\n     and content of the bitmap buffer can change between calls of\n     @FT_Load_Glyph and a few other functions.\n\n   bitmap_left ::\n     The bitmap's left bearing expressed in integer pixels.\n\n   bitmap_top ::\n     The bitmap's top bearing expressed in integer pixels.  This is the\n     distance from the baseline to the top-most glyph scanline, upwards\n     y~coordinates being **positive**.\n\n   outline ::\n     The outline descriptor for the current glyph image if its format is\n     @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is loaded, `outline` can be\n     transformed, distorted, emboldened, etc.  However, it must not be\n     freed.\n\n     [Since 2.10.1] If @FT_LOAD_NO_SCALE is set, outline coordinates of\n     OpenType variation fonts for a selected instance are internally\n     handled as 26.6 fractional font units but returned as (rounded)\n     integers, as expected.  To get unrounded font units, don't use\n     @FT_LOAD_NO_SCALE but load the glyph with @FT_LOAD_NO_HINTING and\n     scale it, using the font's `units_per_EM` value as the ppem.\n\n   num_subglyphs ::\n     The number of subglyphs in a composite glyph.  This field is only\n     valid for the composite glyph format that should normally only be\n     loaded with the @FT_LOAD_NO_RECURSE flag.\n\n   subglyphs ::\n     An array of subglyph descriptors for composite glyphs.  There are\n     `num_subglyphs` elements in there.  Currently internal to FreeType.\n\n   control_data ::\n     Certain font drivers can also return the control data for a given\n     glyph image (e.g.  TrueType bytecode, Type~1 charstrings, etc.).\n     This field is a pointer to such data; it is currently internal to\n     FreeType.\n\n   control_len ::\n     This is the length in bytes of the control data.  Currently internal\n     to FreeType.\n\n   other ::\n     Reserved.\n\n   lsb_delta ::\n     The difference between hinted and unhinted left side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n   rsb_delta ::\n     The difference between hinted and unhinted right side bearing while\n     auto-hinting is active.  Zero otherwise.\n\n @note:\n   If @FT_Load_Glyph is called with default flags (see @FT_LOAD_DEFAULT)\n   the glyph image is loaded in the glyph slot in its native format\n   (e.g., an outline glyph for TrueType and Type~1 formats).  [Since 2.9]\n   The prospective bitmap metrics are calculated according to\n   @FT_LOAD_TARGET_XXX and other flags even for the outline glyph, even\n   if @FT_LOAD_RENDER is not set.\n\n   This image can later be converted into a bitmap by calling\n   @FT_Render_Glyph.  This function searches the current renderer for the\n   native image's format, then invokes it.\n\n   The renderer is in charge of transforming the native image through the\n   slot's face transformation fields, then converting it into a bitmap\n   that is returned in `slot->bitmap`.\n\n   Note that `slot->bitmap_left` and `slot->bitmap_top` are also used to\n   specify the position of the bitmap relative to the current pen\n   position (e.g., coordinates (0,0) on the baseline).  Of course,\n   `slot->format` is also changed to @FT_GLYPH_FORMAT_BITMAP.\n\n   Here is a small pseudo code fragment that shows how to use `lsb_delta`\n   and `rsb_delta` to do fractional positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot     = face->glyph;\n     FT_Pos        origin_x = 0;\n\n\n     for all glyphs do\n       <load glyph with `FT_Load_Glyph'>\n\n       FT_Outline_Translate( slot->outline, origin_x & 63, 0 );\n\n       <save glyph image, or render glyph, or ...>\n\n       <compute kern between current and next glyph\n        and add it to `origin_x'>\n\n       origin_x += slot->advance.x;\n       origin_x += slot->lsb_delta - slot->rsb_delta;\n     endfor\n   ```\n\n   Here is another small pseudo code fragment that shows how to use\n   `lsb_delta` and `rsb_delta` to improve integer positioning of glyphs:\n\n   ```\n     FT_GlyphSlot  slot           = face->glyph;\n     FT_Pos        origin_x       = 0;\n     FT_Pos        prev_rsb_delta = 0;\n\n\n     for all glyphs do\n       <compute kern between current and previous glyph\n        and add it to `origin_x'>\n\n       <load glyph with `FT_Load_Glyph'>\n\n       if ( prev_rsb_delta - slot->lsb_delta >  32 )\n         origin_x -= 64;\n       else if ( prev_rsb_delta - slot->lsb_delta < -31 )\n         origin_x += 64;\n\n       prev_rsb_delta = slot->rsb_delta;\n\n       <save glyph image, or render glyph, or ...>\n\n       origin_x += slot->advance.x;\n     endfor\n   ```\n\n   If you use strong auto-hinting, you **must** apply these delta values!\n   Otherwise you will experience far too large inter-glyph spacing at\n   small rendering sizes in most cases.  Note that it doesn't harm to use\n   the above code for other hinting modes also, since the delta values\n   are zero then."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FT_GlyphSlotRec_ {
    pub library: FT_Library,
    pub face: FT_Face,
    pub next: FT_GlyphSlot,
    pub glyph_index: FT_UInt,
    pub generic: FT_Generic,
    pub metrics: FT_Glyph_Metrics,
    pub linearHoriAdvance: FT_Fixed,
    pub linearVertAdvance: FT_Fixed,
    pub advance: FT_Vector,
    pub format: FT_Glyph_Format,
    pub bitmap: FT_Bitmap,
    pub bitmap_left: FT_Int,
    pub bitmap_top: FT_Int,
    pub outline: FT_Outline,
    pub num_subglyphs: FT_UInt,
    pub subglyphs: FT_SubGlyph,
    pub control_data: *mut ::std::os::raw::c_void,
    pub control_len: ::std::os::raw::c_long,
    pub lsb_delta: FT_Pos,
    pub rsb_delta: FT_Pos,
    pub other: *mut ::std::os::raw::c_void,
    pub internal: FT_Slot_Internal,
}
#[test]
fn bindgen_test_layout_FT_GlyphSlotRec_() {
    const UNINIT: ::std::mem::MaybeUninit<FT_GlyphSlotRec_> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FT_GlyphSlotRec_>(),
        304usize,
        concat!("Size of: ", stringify!(FT_GlyphSlotRec_))
    );
    assert_eq!(
        ::std::mem::align_of::<FT_GlyphSlotRec_>(),
        8usize,
        concat!("Alignment of ", stringify!(FT_GlyphSlotRec_))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).library) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(library)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).face) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glyph_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(glyph_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metrics) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(metrics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linearHoriAdvance) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(linearHoriAdvance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linearVertAdvance) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(linearVertAdvance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).advance) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_left) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap_left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitmap_top) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(bitmap_top)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outline) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(outline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_subglyphs) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(num_subglyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subglyphs) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(subglyphs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_data) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(control_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_len) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(control_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lsb_delta) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(lsb_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsb_delta) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(rsb_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).other) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(other)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(FT_GlyphSlotRec_),
            "::",
            stringify!(internal)
        )
    );
}
extern "C" {
    pub fn hb_ft_face_create(ft_face: FT_Face, destroy: hb_destroy_func_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_ft_face_create_cached(ft_face: FT_Face) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_ft_face_create_referenced(ft_face: FT_Face) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_ft_font_create(ft_face: FT_Face, destroy: hb_destroy_func_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_ft_font_create_referenced(ft_face: FT_Face) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_ft_font_get_face(font: *mut hb_font_t) -> FT_Face;
}
extern "C" {
    pub fn hb_ft_font_lock_face(font: *mut hb_font_t) -> FT_Face;
}
extern "C" {
    pub fn hb_ft_font_unlock_face(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_ft_font_set_load_flags(font: *mut hb_font_t, load_flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_ft_font_get_load_flags(font: *mut hb_font_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hb_ft_font_changed(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_ft_font_set_funcs(font: *mut hb_font_t);
}
